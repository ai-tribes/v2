Directory structure:
â””â”€â”€ ai-tribes-v2/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ checklist.md
    â”œâ”€â”€ eslint.config.mjs
    â”œâ”€â”€ jest.config.js
    â”œâ”€â”€ jest.setup.ts
    â”œâ”€â”€ next.config.js
    â”œâ”€â”€ next.config.ts
    â”œâ”€â”€ package.json
    â”œâ”€â”€ tsconfig.json
    â”œâ”€â”€ .eslintrc.json
    â”œâ”€â”€ .prettierrc
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ SETUP_GUIDE.md
    â”‚   â”œâ”€â”€ analysis/
    â”‚   â”‚   â”œâ”€â”€ 01_structure_issues.txt
    â”‚   â”‚   â”œâ”€â”€ 02_dependencies_config_issues.txt
    â”‚   â”‚   â”œâ”€â”€ 03_code_organization_issues.txt
    â”‚   â”‚   â”œâ”€â”€ 04_payment_integration_issues.txt
    â”‚   â”‚   â”œâ”€â”€ 05_component_routing_issues.txt
    â”‚   â”‚   â”œâ”€â”€ 06_build_output_issues.txt
    â”‚   â”‚   â””â”€â”€ 07_assets_issues.txt
    â”‚   â””â”€â”€ planning/
    â”‚       â”œâ”€â”€ DESIGN_SPECIFIC.md
    â”‚       â”œâ”€â”€ NEW_REPO_STRATEGY.md
    â”‚       â””â”€â”€ PRIORITY_LIST.md
    â”œâ”€â”€ public/
    â””â”€â”€ src/
        â”œâ”€â”€ app/
        â”‚   â”œâ”€â”€ globals.css
        â”‚   â”œâ”€â”€ layout.tsx
        â”‚   â”œâ”€â”€ page.module.css
        â”‚   â”œâ”€â”€ page.tsx
        â”‚   â””â”€â”€ (public)/
        â”‚       â””â”€â”€ examples/
        â”‚           â””â”€â”€ page.tsx
        â”œâ”€â”€ components/
        â”‚   â”œâ”€â”€ layout/
        â”‚   â”‚   â”œâ”€â”€ index.ts
        â”‚   â”‚   â”œâ”€â”€ Footer/
        â”‚   â”‚   â”‚   â”œâ”€â”€ Footer.test.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ Footer.tsx
        â”‚   â”‚   â”‚   â””â”€â”€ Footer.types.ts
        â”‚   â”‚   â”œâ”€â”€ Header/
        â”‚   â”‚   â”‚   â”œâ”€â”€ Header.test.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ Header.tsx
        â”‚   â”‚   â”‚   â”œâ”€â”€ Header.types.ts
        â”‚   â”‚   â”‚   â””â”€â”€ index.ts
        â”‚   â”‚   â””â”€â”€ MainLayout/
        â”‚   â”‚       â”œâ”€â”€ MainLayout.test.tsx
        â”‚   â”‚       â”œâ”€â”€ MainLayout.tsx
        â”‚   â”‚       â””â”€â”€ MainLayout.types.ts
        â”‚   â”œâ”€â”€ shared/
        â”‚   â”‚   â””â”€â”€ index.ts
        â”‚   â””â”€â”€ ui/
        â”‚       â”œâ”€â”€ index.ts
        â”‚       â”œâ”€â”€ Button/
        â”‚       â”‚   â”œâ”€â”€ README.md
        â”‚       â”‚   â”œâ”€â”€ Button.test.tsx
        â”‚       â”‚   â”œâ”€â”€ Button.tsx
        â”‚       â”‚   â”œâ”€â”€ Button.types.ts
        â”‚       â”‚   â””â”€â”€ index.ts
        â”‚       â”œâ”€â”€ Card/
        â”‚       â”‚   â”œâ”€â”€ Card.module.css
        â”‚       â”‚   â”œâ”€â”€ Card.test.tsx
        â”‚       â”‚   â”œâ”€â”€ Card.tsx
        â”‚       â”‚   â”œâ”€â”€ Card.types.ts
        â”‚       â”‚   â””â”€â”€ index.ts
        â”‚       â”œâ”€â”€ Form/
        â”‚       â”‚   â”œâ”€â”€ Form.integration.test.tsx
        â”‚       â”‚   â”œâ”€â”€ Form.test.tsx
        â”‚       â”‚   â”œâ”€â”€ Form.tsx
        â”‚       â”‚   â”œâ”€â”€ Form.types.ts
        â”‚       â”‚   â”œâ”€â”€ FormField.test.tsx
        â”‚       â”‚   â”œâ”€â”€ FormField.tsx
        â”‚       â”‚   â”œâ”€â”€ FormGroup.tsx
        â”‚       â”‚   â””â”€â”€ index.ts
        â”‚       â”œâ”€â”€ Input/
        â”‚       â”‚   â”œâ”€â”€ Input.test.tsx
        â”‚       â”‚   â”œâ”€â”€ Input.tsx
        â”‚       â”‚   â”œâ”€â”€ Input.types.ts
        â”‚       â”‚   â””â”€â”€ index.ts
        â”‚       â””â”€â”€ Modal/
        â”‚           â”œâ”€â”€ Modal.test.tsx
        â”‚           â”œâ”€â”€ Modal.tsx
        â”‚           â”œâ”€â”€ Modal.types.ts
        â”‚           â””â”€â”€ index.ts
        â””â”€â”€ lib/
            â”œâ”€â”€ test-utils.tsx
            â”œâ”€â”€ utils.ts
            â”œâ”€â”€ api/
            â”‚   â”œâ”€â”€ client.ts
            â”‚   â”œâ”€â”€ constants.ts
            â”‚   â”œâ”€â”€ hooks.ts
            â”‚   â”œâ”€â”€ index.ts
            â”‚   â””â”€â”€ types.ts
            â”œâ”€â”€ auth/
            â”‚   â”œâ”€â”€ client.ts
            â”‚   â”œâ”€â”€ context.tsx
            â”‚   â”œâ”€â”€ hooks.ts
            â”‚   â”œâ”€â”€ index.ts
            â”‚   â””â”€â”€ types.ts
            â”œâ”€â”€ blockchain/
            â”‚   â”œâ”€â”€ chains.ts
            â”‚   â”œâ”€â”€ client.ts
            â”‚   â”œâ”€â”€ context.tsx
            â”‚   â”œâ”€â”€ hooks.ts
            â”‚   â”œâ”€â”€ index.ts
            â”‚   â””â”€â”€ types.ts
            â”œâ”€â”€ routing/
            â”‚   â””â”€â”€ types.ts
            â””â”€â”€ storage/
                â”œâ”€â”€ client.ts
                â”œâ”€â”€ encryption.ts
                â”œâ”€â”€ hooks.ts
                â”œâ”€â”€ index.ts
                â”œâ”€â”€ types.ts
                â””â”€â”€ providers/
                    â”œâ”€â”€ ipfs.ts
                    â””â”€â”€ local.ts

================================================
File: /README.md
================================================
# AI Tribes V2 Project Documentation

## Document Organization

### 1. Legacy Analysis (Reference Only)

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

## Next Steps

1. Create New Repository
```bash
# Create new directory
mkdir ai-tribes-v2
cd ai-tribes-v2

# Initialize with Next.js
npx create-next-app@latest . --typescript --app --src-dir --import-alias "@/*"

# Note: This project uses Bootstrap 5 for styling
npm install bootstrap @popperjs/core

# Initialize Git
git init
git add .
git commit -m "feat: Initial commit with fresh Next.js setup"

# Create reference directory
mkdir _reference
cd _reference
git clone https://github.com/your-username/ai-tribes-next.git legacy
```


================================================
File: /checklist.md
================================================
# AI Tribes v2 Project Checklist

## âœ… Completed Tasks

### Project Setup
- [x] Create new Next.js 13 project with App Router
- [x] Set up Vercel deployment
- [x] Test automatic deployment pipeline
- [x] Fix routing issues with public pages
- [x] Verify deployment is working correctly

### Core Infrastructure
- [x] Create core utility folders structure in `src/lib/`
- [x] Set up API utilities with version tracking
- [x] Set up authentication utilities
- [x] Set up blockchain utilities
- [x] Set up storage utilities
- [x] Create placeholder index files for all core utilities

### Development Environment
- [x] Configure ESLint
- [x] Configure Prettier
- [x] Set up testing infrastructure with Jest
- [x] Configure test environment with React Testing Library
- [x] Create test utilities and helpers

### UI Components
- [x] Create Button component with tests
- [x] Create Input component with tests
- [x] Create Modal component with tests
- [x] Create Form components (Form, FormField, FormGroup) with tests
- [x] Set up Bootstrap 5 styling

### Layout Components
- [x] Create Header component with tests
- [x] Create Footer component with tests
  - [x] Implement logo section
  - [x] Add link groups functionality
  - [x] Add social links
  - [x] Add copyright section
  - [x] Add bottom content support
  - [x] Add comprehensive tests

### Type Safety Improvements
- [x] Update design documents with routing type safety requirements
- [x] Create routing type utilities in src/lib/routing/types.ts
- [x] Update Footer component types with proper route types
- [x] Update layout.tsx with proper route handling
- [ ] Update Header component with proper route types
- [ ] Update MainLayout component with proper route types
- [ ] Add tests for route type validation

## ğŸš§ In Progress
- [ ] Implementing route type safety across remaining components
- [ ] Implementing MainLayout component
- [ ] Setting up authentication flow
- [ ] Implementing blockchain integration

## âŒ Known Issues/Deviations
1. FormField component has TypeScript errors with prop passing that need to be resolved
2. Some test files might need additional coverage for edge cases
3. Need to verify Jest configuration works with Next.js 13 app router
4. Header and MainLayout components still need route type updates

## ğŸ“ Todo List

### High Priority
1. Fix FormField TypeScript errors
2. Complete route type safety implementation for remaining components
3. Add tests for route type utilities and components
4. Complete MainLayout component implementation
5. Add more comprehensive test coverage
6. Set up proper error handling system
7. Implement loading states and spinners

### Core Features
1. Implement authentication system
   - Login/Register forms
   - Password reset flow
   - Session management
2. Set up blockchain integration
   - Wallet connection
   - Transaction handling
   - Contract interactions
3. Implement storage system
   - File upload/download
   - IPFS integration
   - Local storage management

### UI/UX
1. Create additional UI components:
   - Select
   - Checkbox
   - Radio
   - Toggle
   - Tooltip
   - Dropdown
2. Implement responsive design
3. Add dark mode support
4. Create loading skeletons
5. Add animations and transitions

### Testing & Documentation
1. Add end-to-end tests with Cypress
2. Create Storybook documentation
3. Write API documentation
4. Add JSDoc comments to all components
5. Create usage examples

### Optimization
1. Implement code splitting
2. Add proper SEO meta tags
3. Optimize images and assets
4. Set up proper caching strategy
5. Implement performance monitoring

### DevOps
1. Set up CI/CD pipeline
2. Configure proper environment variables
3. Set up monitoring and logging
4. Create backup strategy
5. Configure security headers

## ğŸ“Œ Notes
- Need to decide on state management solution (Context vs Redux vs Zustand)
- Consider implementing a component library like shadcn/ui
- May need to add internationalization support
- Consider adding analytics tracking
- Plan for scaling and performance optimization

## ğŸ”„ Next Steps
1. Complete MainLayout component
2. Begin implementing authentication system
3. Set up proper error handling
4. Add loading states and feedback mechanisms 

================================================
File: /eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;


================================================
File: /jest.config.js
================================================
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files in your test environment
  dir: './',
});

// Add any custom config to be passed to Jest
const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.ts'],
  testEnvironment: 'jest-environment-jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
module.exports = createJestConfig(customJestConfig); 

================================================
File: /jest.setup.ts
================================================
import '@testing-library/jest-dom';

// Mock next/navigation
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      prefetch: jest.fn(),
    };
  },
  usePathname() {
    return '';
  },
})); 

================================================
File: /next.config.js
================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  poweredByHeader: false,
  experimental: {
    // Enable modern features
    typedRoutes: true,
  }
};

module.exports = nextConfig; 

================================================
File: /next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  reactStrictMode: true,
  poweredByHeader: false,
  experimental: {
    // Enable modern features
    typedRoutes: true,
  }
};

export default nextConfig;


================================================
File: /package.json
================================================
{
  "name": "ai-tribes-v2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "@types/node": "20.11.19",
    "@types/react": "18.2.56",
    "@types/react-dom": "18.2.19",
    "bootstrap": "^5.3.2",
    "clsx": "^2.1.0",
    "eslint": "8.56.0",
    "eslint-config-next": "14.1.0",
    "next": "14.1.0",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "typescript": "5.3.3"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@types/jest": "^29.5.12",
    "@typescript-eslint/eslint-plugin": "^8.19.1",
    "@typescript-eslint/parser": "^8.19.1",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0"
  }
}


================================================
File: /tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


================================================
File: /.eslintrc.json
================================================
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "error",
    "react/react-in-jsx-scope": "off"
  }
} 

================================================
File: /.prettierrc
================================================
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
} 

================================================
File: /docs/README.md
================================================
# AI Tribes V2 Project Documentation

## Document Organization

### 1. Legacy Analysis (Reference Only)
These documents analyze the current codebase and serve as reference for what to improve:
- `01_structure_issues.txt` - Current structural issues
- `02_dependencies_config_issues.txt` - Current dependency issues
- `03_code_organization_issues.txt` - Current organization issues
- `04_payment_integration_issues.txt` - Current payment issues
- `05_component_routing_issues.txt` - Current routing issues
- `06_build_output_issues.txt` - Current build issues
- `07_assets_issues.txt` - Current asset issues

### 2. Core Strategy Documents (Active)
These are our active planning documents:
- `NEW_REPO_STRATEGY.md` - âœ… Primary strategy for new V2 repo
- `DESIGN_SPECIFIC.md` - Technical architecture and features
- `PRIORITY_LIST.md` - Detailed implementation timeline

### 3. Deprecated Documents (To Be Archived)
These documents were for the old migration approach and should be archived:
- `MIGRATION_STRATEGY.md` - Old migration approach
- `TRANSITION_PLAN.md` - Old transition plan
- `SUMMARY_AND_PRIORITIES.md` - Old summary

## Project Setup Status

The project has been initialized in the ai-tribes-v2 directory with:
- Next.js
- TypeScript
- Bootstrap 5
- Basic directory structure

## Next Steps

1. Complete Development Environment Setup
```bash
# Ensure all core directories exist
mkdir -p src/features
mkdir -p src/components/ui
mkdir -p src/lib

# Set up config files
touch .env.local .env.example
```

2. Configure Essential Tools
- TypeScript configuration
- ESLint setup
- Prettier setup
- Jest configuration
- Husky for Git hooks

3. Begin Implementation
Follow `PRIORITY_LIST.md` for detailed timeline, starting with:
- Basic project structure
- Core UI components with Bootstrap 5
- Authentication system
- Essential features

## Document Updates Needed

1. Update `DESIGN_SPECIFIC.md`:
- Remove references to migration
- Focus on new architecture
- Update implementation phases

2. Update `PRIORITY_LIST.md`:
- Adjust timeline for fresh start
- Remove migration steps
- Add setup phases

3. Create New Documents:
- `SETUP_GUIDE.md` - Detailed setup instructions
- `DEVELOPMENT_WORKFLOW.md` - Development practices
- `TESTING_STRATEGY.md` - Testing approach

Let me know which of these tasks you'd like to tackle next:
1. Complete the development environment setup
2. Update the core strategy documents
3. Begin implementing specific features

================================================
File: /docs/SETUP_GUIDE.md
================================================
# AI Tribes V2 Setup Guide

## Prerequisites
- Node.js 18+ installed
- Git installed
- GitHub account
- Code editor (VS Code recommended)
- Package manager (npm/yarn/pnpm)

## Step-by-Step Setup

### 1. Repository Setup
```bash
# Create project directory
mkdir ai-tribes-v2
cd ai-tribes-v2

# Initialize Next.js project
npx create-next-app@latest . \
  --typescript \
  --tailwind \
  --app \
  --src-dir \
  --import-alias "@/*" \
  --no-eslint \
  --no-prettier

# Initialize Git
git init
git add .
git commit -m "feat: Initial commit with fresh Next.js setup"

# Create reference directory (optional)
mkdir _reference
cd _reference
git clone https://github.com/your-username/ai-tribes-next.git legacy
cd ..
```

### 2. Project Structure Setup
```bash
# Create core directories
mkdir -p src/features
mkdir -p src/components/ui
mkdir -p src/lib
mkdir -p src/types
mkdir -p src/utils
mkdir -p src/hooks
mkdir -p src/styles
mkdir -p public/assets

# Create configuration files
touch .env.local .env.example
touch .prettierrc.json .prettierignore
touch .eslintrc.json .eslintignore
touch jest.config.js
touch tsconfig.json
```

### 3. Dependencies Installation

```bash
# Core dependencies
npm install @tanstack/react-query
npm install @prisma/client
npm install zod
npm install @trpc/server @trpc/client
npm install @stripe/stripe-js

# Development dependencies
npm install -D @types/node @types/react @types/react-dom
npm install -D typescript @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install -D prettier eslint-config-prettier eslint-plugin-prettier
npm install -D jest @testing-library/react @testing-library/jest-dom
npm install -D husky lint-staged
npm install -D prisma
```

### 4. Configuration Files

1. TypeScript Configuration (`tsconfig.json`):
```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "_reference"]
}
```

2. ESLint Configuration (`.eslintrc.json`):
```json
{
  "extends": [
    "next/core-web-vitals",
    "plugin:@typescript-eslint/recommended",
    "prettier"
  ],
  "plugins": ["@typescript-eslint", "prettier"],
  "rules": {
    "prettier/prettier": "error",
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "error"
  }
}
```

3. Prettier Configuration (`.prettierrc.json`):
```json
{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "tabWidth": 2,
  "useTabs": false
}
```

4. Jest Configuration (`jest.config.js`):
```javascript
const nextJest = require('next/jest');

const createJestConfig = nextJest({
  dir: './',
});

const customJestConfig = {
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  moduleDirectories: ['node_modules', '<rootDir>/'],
  testEnvironment: 'jest-environment-jsdom',
};

module.exports = createJestConfig(customJestConfig);
```

### 5. Environment Setup

1. Create `.env.local`:
```env
# App
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Database
DATABASE_URL="postgresql://user:password@localhost:5432/ai_tribes_v2"

# Authentication
NEXTAUTH_SECRET="your-secret-here"
NEXTAUTH_URL="http://localhost:3000"

# Stripe
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="your-key-here"
STRIPE_SECRET_KEY="your-secret-key-here"
```

2. Create `.env.example` (same as above but with placeholder values)

### 6. Git Setup

1. Create `.gitignore`:
```gitignore
# Dependencies
node_modules
.pnp
.pnp.js

# Testing
coverage

# Next.js
.next/
out/

# Production
build
dist

# Misc
.DS_Store
*.pem

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Local env files
.env*.local

# Vercel
.vercel

# TypeScript
*.tsbuildinfo
next-env.d.ts

# Reference
_reference/
```

2. Set up Husky:
```bash
# Initialize Husky
npx husky-init && npm install

# Add pre-commit hook
npx husky add .husky/pre-commit "npx lint-staged"
```

3. Configure lint-staged in `package.json`:
```json
{
  "lint-staged": {
    "*.{ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ]
  }
}
```

### 7. VS Code Setup

1. Create `.vscode/settings.json`:
```json
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  }
}
```

### 8. Initial Test Setup

1. Create `jest.setup.js`:
```javascript
import '@testing-library/jest-dom';
```

2. Add test script to `package.json`:
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch"
  }
}
```

### 9. Verification Steps

1. Run development server:
```bash
npm run dev
```

2. Run tests:
```bash
npm test
```

3. Check linting:
```bash
npm run lint
```

4. Verify Git hooks:
```bash
git commit -m "test: Add test commit"
```

This setup provides a solid foundation for the V2 project with proper tooling and configuration. 

================================================
File: /docs/analysis/01_structure_issues.txt
================================================
Initial Project Structure Issues:

1. Configuration File Redundancy:
   - Multiple Next.js config files present: next.config.js, next.config.mjs, next.config.ts
   - This can cause confusion and potential conflicts
   - Need to standardize on one (preferably next.config.mjs for modern ESM)

2. Legacy/Deprecated Files:
   - 'notpages' directory suggests old Next.js pages structure
   - Contains 'notroadmap.js' and 'nottoken.js' which seem to be deprecated
   - Need to clean up or migrate these to the app router structure

3. Mixed Component Technologies:
   - Mix of .jsx and .tsx files (e.g., in roadmap components)
   - Should standardize on TypeScript (.tsx) for consistency

4. Asset Organization Issues:
   - Multiple version files (ai-tribes-0.0.3.txt, ai-tribes-NEXT.txt)
   - Redundant CSS locations (public/assets/css and src/app/styles)
   - JS files in multiple locations (public/assets/js and src/js)

5. Documentation Structure:
   - Business documents mixed with code (financials.xlsx, roadmap.tex)
   - Should be moved to a dedicated docs directory outside source

6. Component Organization:
   - Some components have their own modules while others share directories
   - Inconsistent module naming (some use index.tsx, others direct names)
   - Need to standardize component organization pattern

7. Static Assets:
   - Many asset directories seem to lack proper organization
   - Multiple directories for similar purposes (images, heroimages, icons)
   - Need to consolidate and organize static assets

8. Build Configuration:
   - Multiple configuration files present (eslint.config.mjs, tsconfig.json)
   - Need to verify all are necessary and properly configured

9. HTML Files in React Project:
   - Standalone HTML files (team.html, token.html) in root
   - These should be converted to React components if still needed

10. Potential Dead Code:
    - 'old' directory in components suggests deprecated code
    - Need to verify if these are still needed or can be removed

Action Items:
1. Consolidate configuration files
2. Clean up deprecated directories and files
3. Standardize on TypeScript
4. Reorganize asset structure
5. Separate documentation from source code
6. Implement consistent component organization
7. Clean up static assets
8. Verify build configurations
9. Convert standalone HTML to React
10. Remove dead code

This is just the initial structural analysis. We'll need to dive deeper into each component and configuration file to identify more specific issues. 

================================================
File: /docs/analysis/02_dependencies_config_issues.txt
================================================
Dependency and Configuration Issues:

1. Next.js Configuration Issues:
   - Three competing Next.js config files (next.config.js, next.config.mjs, next.config.ts)
   - Using Next.js 14.2.22 which isn't a valid version (latest is 14.0.4)
   - Need to standardize on one config file and correct version

2. Package Version Issues:
   - Bootstrap v5.3.3 specified but not yet released (latest is 5.3.2)
   - Very loose version specifications (^) could cause inconsistency issues
   - Some dependencies might need to be moved to devDependencies

3. Missing Critical Dependencies:
   - No ESLint dependencies despite having eslint.config.mjs
   - No styling dependencies (CSS modules are used but no preprocessor specified)
   - No testing framework dependencies
   - No state management library
   - Missing @stripe/stripe-js for frontend Stripe integration

4. TypeScript Configuration:
   - Basic tsconfig.json present but might need stricter settings
   - Using TypeScript but some files are still .js/.jsx
   - No strict mode enabled in tsconfig.json

5. Development Tools:
   - No formatting tools (Prettier) configured
   - No Git hooks (husky, lint-staged) for code quality
   - No build optimization tools configured

6. Security Concerns:
   - Stripe integration but no environment variable handling visible
   - No security-focused dependencies (helmet, cors, etc.)

7. Build Script Issues:
   - Basic Next.js scripts only
   - No testing scripts
   - No type checking script
   - No security audit script
   - No production optimization scripts

Action Items:
1. Standardize Next.js configuration:
   - Remove redundant config files
   - Update to correct Next.js version
   - Configure proper build settings

2. Fix dependency issues:
   - Update to correct versions
   - Add missing critical dependencies
   - Move development dependencies to devDependencies
   - Lock versions more strictly

3. Enhance development setup:
   - Add ESLint with proper configuration
   - Add Prettier
   - Configure Git hooks
   - Add testing framework
   - Add security tools

4. Improve TypeScript configuration:
   - Enable strict mode
   - Add stricter compiler options
   - Configure proper path aliases

5. Enhance build process:
   - Add comprehensive testing script
   - Add type checking script
   - Add security audit script
   - Add production optimization

6. Security improvements:
   - Add security-focused dependencies
   - Configure proper environment variable handling
   - Add security headers

Required New Dependencies:
- eslint and related plugins
- prettier
- husky + lint-staged
- jest + testing-library
- @stripe/stripe-js
- helmet
- proper environment variable handling

This analysis focuses on the build and configuration aspects. We'll need to verify these against the actual codebase usage patterns. 

================================================
File: /docs/analysis/03_code_organization_issues.txt
================================================
Code Organization Issues:

1. Mixed Routing Paradigms:
   - Both /pages and /app directories present
   - This suggests incomplete migration to Next.js 13+ App Router
   - Need to standardize on App Router and remove Pages Router

2. Directory Structure Concerns:
   - Multiple asset locations (/public/assets, /src/assets)
   - Multiple style locations (/src/styles, /app/*.module.css)
   - Potential duplicate functionality between /utils and /hooks
   - Config split between /src/config and root config files

3. Component Organization:
   - Need to verify component categorization
   - Check for component reusability
   - Ensure proper separation of concerns
   - Verify proper use of hooks and contexts

4. Type System:
   - /types directory exists but need to verify coverage
   - Check for proper type exports
   - Verify type usage across components
   - Ensure proper type safety

5. State Management:
   - Multiple contexts in /contexts
   - Need to verify state management patterns
   - Check for prop drilling issues
   - Verify context boundaries

6. Code Duplication:
   - Multiple similar components possible
   - Utils might have duplicate functionality
   - Hooks might have overlapping functionality
   - Styles might have redundant definitions

7. File Organization:
   - Need consistent file naming convention
   - Need consistent directory structure
   - Need proper index exports
   - Need proper module boundaries

8. Code Splitting:
   - Verify proper use of dynamic imports
   - Check bundle sizes
   - Verify route-based code splitting
   - Check for unnecessary imports

Action Items:

1. Routing Migration:
   - Complete migration to App Router
   - Remove Pages Router code
   - Update all routing logic
   - Update all navigation components

2. Asset Organization:
   - Consolidate assets in one location
   - Organize by type and purpose
   - Implement proper asset optimization
   - Set up proper asset loading

3. Component Structure:
   - Implement proper component hierarchy
   - Create shared component library
   - Document component usage
   - Implement proper prop types

4. Type System:
   - Complete type coverage
   - Create proper type exports
   - Implement stricter type checking
   - Document type usage

5. State Management:
   - Review and consolidate contexts
   - Implement proper state patterns
   - Document state flow
   - Optimize state updates

6. Code Quality:
   - Remove duplicate code
   - Create shared utilities
   - Implement proper error boundaries
   - Add proper logging

7. Build Optimization:
   - Implement proper code splitting
   - Optimize bundle sizes
   - Implement proper caching
   - Add performance monitoring

Next Steps:
1. Audit each directory for actual usage
2. Create component inventory
3. Document state flow
4. Create migration plan
5. Implement changes systematically

This is an initial analysis based on directory structure. We'll need to examine actual code files to verify these issues and potentially identify more. 

================================================
File: /docs/analysis/04_payment_integration_issues.txt
================================================
Payment Integration Issues:

1. Multiple Payment Systems:
   - Stripe (traditional payments)
   - Privy (crypto payments)
   - Link.com integration
   - No clear integration strategy between systems

2. Missing Dependencies:
   - Stripe dependencies not properly installed (@stripe/stripe-js missing)
   - Privy dependencies not installed
   - Link.com SDK/dependencies not identified

3. Configuration Issues:
   - No environment variables set up for API keys
   - No secure credential management
   - Missing webhook configurations
   - No error handling setup

4. Integration Status:
   - Payment flows incomplete
   - Subscription management not implemented
   - Webhook handlers missing
   - Success/failure pages not created

5. Security Concerns:
   - Input validation missing
   - No rate limiting
   - No fraud detection
   - Missing error boundaries
   - No monitoring or alerts

6. Testing Gaps:
   - No unit tests
   - No integration tests
   - No end-to-end tests
   - No performance testing
   - Edge cases not covered

7. Documentation Needs:
   - Setup process undocumented
   - Missing API documentation
   - No troubleshooting guide
   - Security measures undocumented
   - User guides needed

Action Items:

1. Dependencies Setup:
   - Install @stripe/stripe-js
   - Install Privy SDK
   - Research and install Link.com requirements
   - Add all payment-related types

2. Environment Configuration:
   - Set up .env.local
   - Configure API keys
   - Set up webhook endpoints
   - Configure error handling

3. Implementation Priority:
   1. Stripe Integration (most standard)
   2. Privy Integration (crypto payments)
   3. Link.com Integration (additional option)

4. Security Implementation:
   - Add input validation
   - Implement rate limiting
   - Set up monitoring
   - Add error boundaries
   - Implement fraud detection

5. Testing Setup:
   - Create test environment
   - Write unit tests
   - Set up integration tests
   - Implement E2E tests
   - Add performance tests

6. Documentation:
   - Create setup guide
   - Document API endpoints
   - Write troubleshooting guide
   - Document security measures
   - Create user guides

Critical Issues to Address First:
1. Missing payment dependencies
2. Lack of environment configuration
3. Absent security measures
4. No testing infrastructure
5. Missing documentation

This analysis shows that the payment integration is in very early stages and needs significant work before it can be production-ready. 

================================================
File: /docs/analysis/05_component_routing_issues.txt
================================================
Component and Routing Issues:

1. Component Organization Problems:
   - Flat component structure with 20+ top-level directories
   - Mix of feature-based and type-based organization
   - Inconsistent component naming (some PascalCase, some kebab-case)
   - No clear shared/common components strategy

2. App Router Implementation Issues:
   - Incomplete migration (still has pages directory)
   - Missing route groups for better organization
   - No error boundaries or loading states in many routes
   - Inconsistent use of server/client components

3. Component Architecture Issues:
   - Basic Button component at root level
   - ClientBootstrap suggests client/server component confusion
   - No clear pattern for component composition
   - Missing component documentation

4. Feature Organization:
   - Multiple related features split across directories:
     * Payment, Pricing, and Wallet could be consolidated
     * Auth and KYC could be combined
     * Team and Social Media might overlap
   - No clear boundaries between features

5. Styling Issues:
   - Multiple CSS approaches:
     * Global CSS in app/globals.css
     * CSS Modules scattered across components
     * Inline styles likely present
   - No consistent styling strategy
   - Large CSS files (landing.module.css is 6.9KB)

6. Layout and Navigation:
   - Multiple navigation components (Navbar, Header)
   - Layout implementation might not use new App Router layouts
   - Potential duplicate layout code
   - No clear responsive design strategy

7. API Integration:
   - API routes mixed with pages
   - No clear API versioning strategy
   - Missing API documentation
   - No clear error handling pattern

8. Performance Concerns:
   - Large component directories suggest possible code splitting issues
   - No clear lazy loading strategy
   - Multiple CSS files could affect performance
   - Static and dynamic rendering not clearly separated

Action Items:

1. Component Reorganization:
   - Implement feature-based organization
   - Create shared component library
   - Standardize naming conventions
   - Add component documentation

2. App Router Migration:
   - Complete migration from pages to app router
   - Implement proper loading states
   - Add error boundaries
   - Use route groups for organization

3. Feature Consolidation:
   - Combine related features
   - Establish clear feature boundaries
   - Implement proper data flow
   - Document feature interactions

4. Styling Strategy:
   - Choose primary styling approach
   - Implement design system
   - Consolidate CSS files
   - Add responsive design patterns

5. Performance Optimization:
   - Implement code splitting
   - Add lazy loading
   - Optimize CSS delivery
   - Separate static/dynamic content

6. API Architecture:
   - Organize API routes
   - Implement versioning
   - Add proper error handling
   - Create API documentation

Priority Issues:
1. Complete App Router migration
2. Consolidate related features
3. Implement consistent styling strategy
4. Add proper error handling
5. Document component usage

This analysis reveals significant architectural issues that need to be addressed for better maintainability and performance. 

================================================
File: /docs/analysis/06_build_output_issues.txt
================================================
Build Output Issues:

1. Build Manifest Issues:
   - Empty app-build-manifest.json suggests incomplete build
   - Empty react-loadable-manifest.json indicates no code splitting
   - Build manifest shows minimal page generation

2. Build Configuration Problems:
   - Multiple next.config files causing confusion
   - No clear optimization settings
   - Missing important Next.js features:
     * Image optimization
     * Font optimization
     * Script optimization

3. Static Generation Issues:
   - Limited static content generation
   - No clear static/dynamic split
   - Missing static optimization opportunities
   - No clear caching strategy

4. Server Components:
   - No clear server component strategy
   - Missing streaming implementation
   - No clear data fetching patterns
   - Potential client/server confusion

5. Type Generation:
   - Types directory present but might be incomplete
   - No clear type checking in build process
   - Potential type mismatches
   - Missing type generation steps

6. Cache Management:
   - Cache directory present but usage unclear
   - No clear caching strategy
   - Missing cache invalidation
   - No build cache optimization

7. Build Performance:
   - Trace file suggests potential performance issues
   - No clear chunking strategy
   - Missing performance optimizations
   - Build time could be improved

Action Items:

1. Build Configuration:
   - Standardize next.config
   - Enable all relevant optimizations
   - Configure proper build settings
   - Add performance monitoring

2. Static Generation:
   - Identify static pages
   - Implement ISR where appropriate
   - Configure proper caching
   - Optimize static assets

3. Server Components:
   - Implement proper streaming
   - Configure data fetching
   - Add proper boundaries
   - Document patterns

4. Type System:
   - Complete type coverage
   - Add build-time type checking
   - Generate proper types
   - Add type testing

5. Cache Strategy:
   - Implement proper caching
   - Add cache invalidation
   - Optimize build cache
   - Document caching

6. Performance:
   - Add code splitting
   - Optimize chunks
   - Implement lazy loading
   - Monitor build times

Critical Issues:
1. Incomplete builds
2. Missing optimizations
3. Poor caching strategy
4. Type system gaps
5. Performance concerns

Next Steps:
1. Fix build configuration
2. Implement proper optimizations
3. Add comprehensive type checking
4. Optimize caching
5. Monitor and improve performance

This analysis shows significant build and optimization issues that need to be addressed for proper production deployment. 

================================================
File: /docs/analysis/07_assets_issues.txt
================================================
Asset Management Issues:

1. Asset Organization:
   - Scattered SVG files in public root
   - Multiple overlapping directories (images, heroimages, icons)
   - No clear naming convention
   - Redundant assets likely present

2. Asset Optimization:
   - Large video file (3.5MB herovideo1.mp4) without optimization
   - PNG files not optimized (tribes_logo.png is 255KB)
   - No WebP alternatives for images
   - No responsive image sizes

3. Asset Location Issues:
   - JS files in public/assets/js (should be in src)
   - CSS files in public/assets/css (should be in src)
   - Documentation in public/assets/docs (should be outside)
   - Mixing of asset types

4. Directory Structure:
   - Too many top-level directories
   - Similar content split across directories:
     * social/ and socialloginpng/
     * images/, heroimages/, and icons/
     * logos/ and tribes_logo.png
   - No clear organization strategy

5. Missing Optimizations:
   - No image lazy loading configuration
   - No video streaming setup
   - No asset preloading strategy
   - No clear caching policy

6. Asset Version Control:
   - Large binary files in git
   - No clear asset versioning strategy
   - Missing asset optimization in build process
   - No CDN configuration

Action Items:

1. Asset Reorganization:
   - Consolidate similar directories
   - Implement clear naming convention
   - Move non-public files to src
   - Create proper asset hierarchy

2. Asset Optimization:
   - Implement image optimization
   - Add video compression
   - Generate WebP versions
   - Create responsive sizes

3. Build Process:
   - Add asset optimization step
   - Configure proper caching
   - Implement preloading
   - Set up CDN delivery

4. Directory Structure:
   - /public
     â”œâ”€â”€ static/
     â”‚   â”œâ”€â”€ images/
     â”‚   â”‚   â”œâ”€â”€ icons/
     â”‚   â”‚   â”œâ”€â”€ logos/
     â”‚   â”‚   â””â”€â”€ photos/
     â”‚   â”œâ”€â”€ videos/
     â”‚   â””â”€â”€ fonts/
     â””â”€â”€ assets/
         â”œâ”€â”€ tribes/
         â”œâ”€â”€ marketing/
         â””â”€â”€ docs/

5. Asset Management:
   - Implement proper lazy loading
   - Add asset versioning
   - Configure caching
   - Set up monitoring

Critical Issues:
1. Unoptimized assets
2. Poor directory organization
3. Misplaced source files
4. Missing build optimizations
5. No CDN strategy

This analysis shows significant issues with asset management that need to be addressed for better performance and maintainability. 

================================================
File: /docs/planning/DESIGN_SPECIFIC.md
================================================
# AI Tribes Next.js Project Design Document

## Project Overview
AI Tribes is a platform for creating and managing AI-powered communities with specific focus on:
- Tribe-based organization of AI communities
- Multi-chain wallet integration
- Social media features
- Token-gated access
- KYC verification

## Architecture Evolution

### Current State
Our codebase currently has:
- Organized component structure with proper routing
- Next.js App Router implementation
- Type-safe routing implementation
- Bootstrap 5 styling framework
- Strong separation of concerns

### Target State
We're continuing to evolve towards:
- Feature-based architecture
- Clear separation of concerns
- Type-safe implementations
- Proper testing coverage

## Feature Modules

### 1. Authentication & KYC
Current:
- Scattered across `src/components/auth/` and `src/components/kyc/`
- Mixed authentication methods
- Incomplete KYC flow

Target (`src/features/auth/`):
```
auth/
â”œâ”€â”€ components/          # Auth UI components
â”‚   â”œâ”€â”€ Login/
â”‚   â”œâ”€â”€ KYC/
â”‚   â””â”€â”€ Profile/
â”œâ”€â”€ api/                # Auth API routes
â”œâ”€â”€ hooks/              # Auth-related hooks
â”œâ”€â”€ types/              # Auth types
â””â”€â”€ utils/              # Auth utilities
```

### 2. Wallet Integration
Current:
- Isolated in `src/components/wallet/`
- Basic wallet connection
- Limited chain support

Target (`src/features/wallet/`):
```
wallet/
â”œâ”€â”€ components/         # Wallet UI components
â”œâ”€â”€ api/               # Blockchain interactions
â”œâ”€â”€ hooks/             # Wallet hooks
â”œâ”€â”€ types/             # Wallet & chain types
â””â”€â”€ utils/             # Blockchain utilities
```

### 3. Tribe Management
Current:
- Basic implementation in `src/components/tribes/`
- Limited functionality
- No proper data management

Target (`src/features/tribes/`):
```
tribes/
â”œâ”€â”€ components/         # Tribe UI components
â”œâ”€â”€ api/               # Tribe management API
â”œâ”€â”€ hooks/             # Tribe-related hooks
â”œâ”€â”€ types/             # Tribe types
â””â”€â”€ utils/             # Tribe utilities
```

### 4. Payment Systems
Current:
- Split between `payment/` and `pricing/`
- Incomplete integrations
- No proper error handling

Target (`src/features/payments/`):
```
payments/
â”œâ”€â”€ components/         # Payment UI components
â”‚   â”œâ”€â”€ stripe/
â”‚   â””â”€â”€ crypto/
â”œâ”€â”€ api/               # Payment processing
â”œâ”€â”€ hooks/             # Payment hooks
â”œâ”€â”€ types/             # Payment types
â””â”€â”€ utils/             # Payment utilities
```

## Core Infrastructure

### 1. Shared Components
```
src/components/
â”œâ”€â”€ ui/                # Basic UI components with Bootstrap 5
â”‚   â”œâ”€â”€ Button/
â”‚   â”œâ”€â”€ Modal/
â”‚   â””â”€â”€ Form/
â”œâ”€â”€ layout/            # Layout components with type-safe routing
â”‚   â”œâ”€â”€ Header/
â”‚   â”œâ”€â”€ Footer/
â”‚   â””â”€â”€ MainLayout/
â””â”€â”€ shared/            # Shared feature components
```

### 2. Core Utilities
```
src/lib/
â”œâ”€â”€ api/              # API utilities
â”œâ”€â”€ auth/             # Auth utilities
â”œâ”€â”€ blockchain/       # Blockchain utilities
â”œâ”€â”€ storage/          # Storage utilities
â””â”€â”€ routing/          # Type-safe routing utilities
    â”œâ”€â”€ types.ts      # Route type definitions
    â””â”€â”€ utils.ts      # Route helper functions
```

### 3. App Router Structure
```
src/app/
â”œâ”€â”€ (auth)/           # Auth routes
â”œâ”€â”€ (dashboard)/      # Dashboard routes
â”œâ”€â”€ (public)/         # Public routes
â””â”€â”€ api/              # API routes
```

## Technical Implementation

### 1. TypeScript Integration
- Strict mode enabled
- Comprehensive type definitions
- Type-safe API calls
- Proper error handling

### 2. Routing Type Safety
- Implemented Next.js Route types for all internal links
- Enforced URL object usage for external links
- Type-safe route parameters using `src/lib/routing/types.ts`
- Helper utilities for route type conversion (`createInternalRoute`, `createExternalRoute`)
- Route type validation in layout components (Header, Footer, MainLayout)
- Navigation link types with proper route type checking
- Social link types extending navigation links with icon support

### 3. Testing Strategy
- Jest for unit testing
- React Testing Library for components
- Cypress for E2E testing
- Integration tests for features

### 4. State Management
- React Context for UI state
- Server state with React Query
- Proper data caching
- Optimistic updates

### 5. Performance Optimization
- Route-based code splitting
- Asset optimization
- Proper caching strategy
- Lazy loading

### 2. Routing Type Safety
- Implemented Next.js Route types for all internal links
- Enforced URL object usage for external links
- Type-safe route parameters using `src/lib/routing/types.ts`
- Helper utilities for route type conversion (`createInternalRoute`, `createExternalRoute`)
- Route type validation in layout components (Header, Footer, MainLayout)
- Navigation link types with proper route type checking
- Social link types extending navigation links with icon support

### 3. UI Framework
- Bootstrap 5 as primary styling framework
- Custom utility classes for enhanced styling
- Responsive design patterns
- Consistent component styling
- Integration with Next.js components

## Implementation Phases

### Phase 1: Foundation (Week 1)
1. Project Structure
   - Set up new directory structure
   - Configure TypeScript
   - Set up testing infrastructure
   - Configure build tools

2. Core Components
   - Create UI component library
   - Set up layouts
   - Implement shared utilities
   - Add basic types

### Phase 2: Feature Migration (Weeks 2-3)
1. Auth & Wallet
   - Migrate auth components
   - Implement wallet integration
   - Add KYC flow
   - Set up session management

2. Tribes & Social
   - Migrate tribe components
   - Implement social features
   - Add resource management
   - Set up activity tracking

### Phase 3: Payment & Integration (Week 4)
1. Payment Systems
   - Implement Stripe integration
   - Add crypto payments
   - Set up subscriptions
   - Add payment processing

2. Feature Integration
   - Connect all features
   - Add proper error handling
   - Implement monitoring
   - Add analytics

### Phase 4: Polish & Launch (Week 5)
1. Testing & Documentation
   - Complete test coverage
   - Add documentation
   - Performance optimization
   - Security audit

2. Deployment
   - Configure CI/CD
   - Set up monitoring
   - Add logging
   - Launch preparation

## Success Metrics

### 1. Code Quality
- 100% TypeScript coverage
- No any types
- All tests passing
- Clean lint results

### 2. Performance
- < 1s initial load
- < 100ms API responses
- 90+ Lighthouse score
- Optimized assets

### 3. User Experience
- Seamless auth flow
- Fast wallet connections
- Smooth transitions
- Proper error handling

This design document will be updated as we progress through the transition plan. 

================================================
File: /docs/planning/NEW_REPO_STRATEGY.md
================================================
# AI Tribes V2 Repository Strategy

## Initial Setup

1. Create New Repository:
```bash
mkdir ai-tribes-v2
cd ai-tribes-v2
git init
```

2. Reference Setup (Optional):
```bash
mkdir _reference
cd _reference
git clone https://github.com/your-username/ai-tribes-next.git legacy
```

## Repository Structure
```
ai-tribes-v2/
â”œâ”€â”€ src/                    # New clean architecture
â”‚   â”œâ”€â”€ features/          # Feature modules
â”‚   â”œâ”€â”€ components/        # Shared components
â”‚   â””â”€â”€ app/              # Next.js app
â”œâ”€â”€ public/                # Public assets
â”œâ”€â”€ _reference/            # (Optional) For reference only
â”‚   â””â”€â”€ legacy/           # Clone of old repo
â””â”€â”€ package.json          # Fresh dependencies
```

## Setup Process

### 1. Initialize New Project
```bash
# Create new Next.js project with latest features
npx create-next-app@latest ai-tribes-v2 --typescript --tailwind --app --src-dir --import-alias "@/*"

# Move into project directory
cd ai-tribes-v2

# Initialize Git
git init
git add .
git commit -m "feat: Initial commit with fresh Next.js setup"
```

### 2. Create Basic Structure
```bash
# Create core directories
mkdir -p src/features
mkdir -p src/components/ui
mkdir -p src/lib

# Add initial configuration files
touch .env.local
touch .env.example
```

### 3. Development Setup

1. Package.json (Fresh start):
```json
{
  "name": "ai-tribes-v2",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "type-check": "tsc --noEmit"
  }
}
```

2. Next.js Configuration:
```typescript
// next.config.mjs
const config = {
  reactStrictMode: true,
  images: {
    domains: ['your-domains-here'],
  },
  // Start with minimal configuration
  // Add features as needed
};

export default config;
```

## Development Workflow

### 1. Feature Implementation
- Start fresh with each feature
- Reference old code only when needed
- Implement with new best practices
- No copy-pasting from old codebase

### 2. Asset Management
- Start with fresh assets in `public/`
- Optimize all assets before adding
- Use modern image formats (WebP)
- Implement proper lazy loading

### 3. Code Quality
- Start with strict TypeScript
- Implement ESLint from day one
- Set up Prettier
- Add test infrastructure immediately

## Deployment Strategy

### 1. Development
- Deploy to new domain/subdomain
- No connection to old deployment
- Fresh environment variables
- New database instance

### 2. Testing
- Fresh test environment
- New test database
- No shared resources with legacy

### 3. Production
- Deploy to separate infrastructure
- Use new domain initially
- Plan domain transition later

## Version Control Best Practices

### 1. Commit Strategy
```
feat: Add new feature
fix: Fix issue in new code
docs: Update documentation
style: Format code
refactor: Refactor implementation
test: Add tests
```

### 2. Branch Strategy (Simple)
- `main`: Primary development
- `feature/*`: New features
- `fix/*`: Bug fixes
- No need for complex branching

## Reference Strategy

### 1. Using Legacy Code
- Never copy-paste directly
- Study patterns and improve
- Document what was referenced
- Note improvements made

### 2. Asset Migration
- Copy needed assets to new `public/`
- Optimize during migration
- Update all asset references
- Document asset sources

## Success Criteria

### 1. Clean Codebase
- No legacy patterns
- Full TypeScript coverage
- Comprehensive tests
- Clear documentation

### 2. Better Performance
- Improved load times
- Better optimization
- Cleaner code splits
- Optimized assets

### 3. Enhanced Features
- Improved implementations
- Better user experience
- Cleaner architecture
- Modern best practices

### 4. Documentation
- Fresh documentation
- Clear architecture docs
- API documentation
- Setup guides

This strategy provides a clean slate while keeping the old code available for reference when needed. 

================================================
File: /docs/planning/PRIORITY_LIST.md
================================================
# AI Tribes Priority List

## Week 1: Foundation
### Day 1-2: Project Structure
1. Set up new directory structure
   - Create `src/features/`
   - Create `src/lib/`
   - Set up proper `src/components/`

2. Configure Build Tools
   - Standardize Next.js config
   - Set up TypeScript properly
   - Configure ESLint and Prettier
   - Set up testing infrastructure

### Day 3-4: Core Components
1. UI Component Library
   - Move and refactor basic components
   - Set up shared components
   - Implement layout system
   - Add basic styling system

2. Type System
   - Set up base types
   - Configure path aliases
   - Add utility types
   - Set up API types

### Day 5: Initial Testing
1. Testing Setup
   - Configure Jest
   - Set up React Testing Library
   - Add initial tests
   - Configure test scripts

## Week 2: Auth & Wallet
### Day 1-2: Authentication
1. Auth Feature Setup
   - Create auth feature structure
   - Move auth components
   - Set up auth hooks
   - Add proper types

2. KYC Integration
   - Move KYC components
   - Set up KYC flow
   - Add validation
   - Implement error handling

### Day 3-5: Wallet Integration
1. Wallet Feature
   - Create wallet feature structure
   - Move wallet components
   - Add chain support
   - Implement transactions

2. Integration
   - Connect auth and wallet
   - Add session management
   - Implement proper error handling
   - Add tests

## Week 3: Tribes & Social
### Day 1-3: Tribe Management
1. Tribe Feature
   - Create tribe feature structure
   - Move tribe components
   - Add CRUD operations
   - Implement validation

2. Resource Management
   - Add resource handling
   - Set up permissions
   - Implement sharing
   - Add tests

### Day 4-5: Social Features
1. Social Integration
   - Set up social features
   - Add activity tracking
   - Implement connections
   - Add notifications

## Week 4: Payments & Integration
### Day 1-3: Payment Systems
1. Payment Feature
   - Create payment structure
   - Implement Stripe
   - Add crypto payments
   - Set up subscriptions

2. Processing
   - Add webhooks
   - Implement callbacks
   - Set up error handling
   - Add security measures

### Day 4-5: Feature Integration
1. Connect Features
   - Integrate all systems
   - Add proper state management
   - Implement caching
   - Add monitoring

## Week 5: Polish & Launch
### Day 1-2: Testing & Documentation
1. Complete Testing
   - Add remaining tests
   - Set up E2E tests
   - Add integration tests
   - Document features

### Day 3-4: Optimization
1. Performance
   - Optimize assets
   - Add code splitting
   - Implement caching
   - Add monitoring

### Day 5: Launch Prep
1. Final Steps
   - Security audit
   - Performance testing
   - Documentation review
   - Deployment preparation

## Success Criteria for Each Phase

### Week 1
- New directory structure in place
- TypeScript configured
- Basic components working
- Initial tests running

### Week 2
- Auth system working
- Wallet integration complete
- KYC flow functional
- Tests passing

### Week 3
- Tribe management working
- Social features functional
- Resource sharing working
- Integration tests passing

### Week 4
- Payment systems working
- Features integrated
- Error handling complete
- Security measures in place

### Week 5
- All tests passing
- Documentation complete
- Performance optimized
- Ready for deployment

This priority list aligns with our transition plan and design document, providing a clear path forward. 

================================================
File: /src/app/globals.css
================================================
:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: var(--font-inter), Arial, Helvetica, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}


================================================
File: /src/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { MainLayout } from "@/components/layout";
import { createInternalRoute, createExternalRoute } from "@/lib/routing/types";
import "bootstrap/dist/css/bootstrap.min.css";
import "./globals.css";

const inter = Inter({
  subsets: ["latin"],
  display: "swap",
  variable: "--font-inter",
});

export const metadata: Metadata = {
  title: "AI Tribes",
  description: "The future of AI collaboration",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const headerProps = {
    logo: <div className="fs-4 fw-semibold">AI Tribes</div>,
    navigation: [
      { label: "Home", href: createInternalRoute("/") },
      { label: "Examples", href: createInternalRoute("/examples") },
      { label: "About", href: createInternalRoute("/about") },
    ],
  };

  const footerProps = {
    linkGroups: [
      {
        title: "Product",
        links: [
          { label: "Features", href: createInternalRoute("/features") },
          { label: "Examples", href: createInternalRoute("/examples") },
          { label: "Documentation", href: createInternalRoute("/docs") },
        ],
      },
      {
        title: "Company",
        links: [
          { label: "About", href: createInternalRoute("/about") },
          { label: "Blog", href: createInternalRoute("/blog") },
          { label: "Contact", href: createInternalRoute("/contact") },
        ],
      },
    ],
    socialLinks: [
      {
        icon: (
          <svg
            className="h-6 w-6"
            fill="currentColor"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.107 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84" />
          </svg>
        ),
        href: createExternalRoute("https://twitter.com/aitribes"),
        label: "Twitter",
        isExternal: true,
      },
      {
        icon: (
          <svg
            className="h-6 w-6"
            fill="currentColor"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path
              fillRule="evenodd"
              d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z"
              clipRule="evenodd"
            />
          </svg>
        ),
        href: createExternalRoute("https://github.com/aitribes"),
        label: "GitHub",
        isExternal: true,
      },
    ],
  };

  return (
    <html lang="en" className={inter.variable}>
      <body>
        <MainLayout headerProps={headerProps} footerProps={footerProps}>
          {children}
        </MainLayout>
      </body>
    </html>
  );
}


================================================
File: /src/app/page.module.css
================================================
.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-inter);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-inter);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 180px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}


================================================
File: /src/app/page.tsx
================================================
import Image from "next/image";
import styles from "./page.module.css";

export default function Home() {
  return (
    <div className={styles.page}>
      <main className={styles.main}>
        <Image
          className={styles.logo}
          src="/next.svg"
          alt="Next.js logo"
          width={180}
          height={38}
          priority
        />
        <ol>
          <li>
            Get started by editing <code>src/app/page.tsx</code>.
          </li>
          <li>Save and see your changes instantly.</li>
        </ol>

        <div className={styles.ctas}>
          <a
            className={styles.primary}
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className={styles.logo}
              src="/vercel.svg"
              alt="Vercel logomark"
              width={20}
              height={20}
            />
            Deploy now
          </a>
          <a
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
            className={styles.secondary}
          >
            Read our docs
          </a>
        </div>
      </main>
      <footer className={styles.footer}>
        <a
          href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/file.svg"
            alt="File icon"
            width={16}
            height={16}
          />
          Learn
        </a>
        <a
          href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/window.svg"
            alt="Window icon"
            width={16}
            height={16}
          />
          Examples
        </a>
        <a
          href="https://nextjs.org?utm_source=create-next-app&utm_medium=appdir-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <Image
            aria-hidden
            src="/globe.svg"
            alt="Globe icon"
            width={16}
            height={16}
          />
          Go to nextjs.org â†’
        </a>
      </footer>
    </div>
  );
}


================================================
File: /src/app/(public)/examples/page.tsx
================================================
import { ExampleCard } from '@/components/ui/Card';

export default function ExamplesPage() {
  const examples = [
    {
      title: "Basic Example",
      description: "A simple example showing basic components and styling with Bootstrap 5.",
      ctaText: "Learn More",
      ctaHref: "#"
    },
    {
      title: "Advanced Features",
      description: "Explore advanced features and integrations available in the platform.",
      ctaText: "Explore",
      ctaHref: "#"
    },
    {
      title: "API Integration",
      description: "Learn how to integrate with our API and build custom solutions.",
      ctaText: "View Docs",
      ctaHref: "#"
    }
  ];

  return (
    <div className="container py-5">
      <h1 className="mb-4">AI Tribes Examples</h1>
      
      <div className="row g-4">
        {examples.map((example, index) => (
          <div key={index} className="col-md-6 col-lg-4">
            <ExampleCard {...example} />
          </div>
        ))}
      </div>
    </div>
  );
} 

================================================
File: /src/components/layout/index.ts
================================================
export * from './Header/Header';
export * from './Footer/Footer';
export * from './MainLayout/MainLayout'; 

================================================
File: /src/components/layout/Footer/Footer.test.tsx
================================================
import { render, screen } from '@/lib/test-utils';
import { Footer } from './Footer';

describe('Footer', () => {
  const mockLogo = <div data-testid="mock-logo">Logo</div>;
  const mockIcon = <svg data-testid="mock-icon" />;
  
  const defaultProps = {
    logo: mockLogo,
    linkGroups: [
      {
        title: 'Company',
        links: [
          { label: 'About', href: '/about' },
          { label: 'Blog', href: '/blog', isExternal: true },
        ],
      },
      {
        title: 'Legal',
        links: [
          { label: 'Privacy', href: '/privacy' },
          { label: 'Terms', href: '/terms' },
        ],
      },
    ],
    copyright: 'Test Copyright',
    socialLinks: [
      { icon: mockIcon, href: 'https://twitter.com', label: 'Twitter' },
      { icon: mockIcon, href: 'https://github.com', label: 'GitHub' },
    ],
    bottomContent: <div data-testid="bottom-content">Additional Content</div>,
  };

  it('renders all sections correctly', () => {
    render(<Footer {...defaultProps} />);
    
    // Logo
    expect(screen.getByTestId('mock-logo')).toBeInTheDocument();
    
    // Link groups
    defaultProps.linkGroups.forEach(group => {
      expect(screen.getByText(group.title)).toBeInTheDocument();
      group.links.forEach(link => {
        const linkElement = screen.getByText(link.label);
        expect(linkElement).toBeInTheDocument();
        expect(linkElement.closest('a')).toHaveAttribute('href', link.href);
        if (link.isExternal) {
          expect(linkElement.closest('a')).toHaveAttribute('target', '_blank');
          expect(linkElement.closest('a')).toHaveAttribute('rel', 'noopener noreferrer');
        }
      });
    });
    
    // Copyright
    expect(screen.getByText(defaultProps.copyright)).toBeInTheDocument();
    
    // Social links
    defaultProps.socialLinks.forEach(social => {
      const link = screen.getByLabelText(social.label);
      expect(link).toBeInTheDocument();
      expect(link).toHaveAttribute('href', social.href);
      expect(link.querySelector('svg')).toBeInTheDocument();
    });
    
    // Bottom content
    expect(screen.getByTestId('bottom-content')).toBeInTheDocument();
  });

  it('uses default copyright text when not provided', () => {
    render(<Footer />);
    const currentYear = new Date().getFullYear();
    expect(screen.getByText(`Â© ${currentYear} AI Tribes. All rights reserved.`)).toBeInTheDocument();
  });

  it('shows border by default', () => {
    const { container } = render(<Footer />);
    expect(container.firstChild).toHaveClass('border-t');
  });

  it('hides border when showBorder is false', () => {
    const { container } = render(<Footer showBorder={false} />);
    expect(container.firstChild).not.toHaveClass('border-t');
  });

  it('applies custom className', () => {
    const { container } = render(<Footer className="custom-class" />);
    expect(container.firstChild).toHaveClass('custom-class');
  });
}); 

================================================
File: /src/components/layout/Footer/Footer.tsx
================================================
import Link from 'next/link';
import { FooterProps } from './Footer.types';
import { cn } from '@/lib/utils';
import { isExternalRoute } from '@/lib/routing/types';

export function Footer({ 
  logo,
  linkGroups = [],
  copyright = `Â© ${new Date().getFullYear()} AI Tribes. All rights reserved.`,
  socialLinks = [],
  bottomContent,
  showBorder = true,
  className
}: FooterProps) {
  return (
    <footer className={cn('bg-white', showBorder && 'border-top', className)}>
      <div className="container py-5">
        <div className="row">
          {/* Logo section */}
          {logo && (
            <div className="col-12 col-xl-4 mb-4 mb-xl-0">
              {logo}
            </div>
          )}
          
          {/* Link groups */}
          <div className={cn(
            "col-12",
            logo ? "col-xl-8" : "col-xl-12"
          )}>
            <div className="row row-cols-1 row-cols-md-2 g-4">
              {linkGroups.map((group) => (
                <div key={group.title} className="col">
                  <h3 className="h6 mb-3">{group.title}</h3>
                  <ul className="nav flex-column">
                    {group.links.map((link) => (
                      <li key={link.label} className="nav-item">
                        {isExternalRoute(link.href) ? (
                          <a
                            href={link.href}
                            className="nav-link px-0 py-1 text-muted"
                            target="_blank"
                            rel="noopener noreferrer"
                          >
                            {link.label}
                          </a>
                        ) : (
                          <Link
                            href={link.href}
                            className="nav-link px-0 py-1 text-muted"
                          >
                            {link.label}
                          </Link>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* Bottom section */}
        <div className="border-top mt-4 pt-4">
          {bottomContent}
          <div className="d-flex flex-column flex-sm-row justify-content-between align-items-center mt-3">
            <p className="text-muted small mb-3 mb-sm-0">{copyright}</p>
            
            {/* Social links */}
            {socialLinks.length > 0 && (
              <div className="nav">
                {socialLinks.map((social) => (
                  <a
                    key={social.label}
                    href={social.href}
                    className="nav-link text-muted px-2"
                    target="_blank"
                    rel="noopener noreferrer"
                    aria-label={social.label}
                  >
                    {social.icon}
                  </a>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </footer>
  );
} 

================================================
File: /src/components/layout/Footer/Footer.types.ts
================================================
import { ReactNode } from 'react';
import { NavigationGroup, SocialLink } from '@/lib/routing/types';

export interface FooterProps {
  /**
   * The site logo/brand element
   */
  logo?: ReactNode;

  /**
   * Groups of links to display in columns
   */
  linkGroups?: NavigationGroup[];

  /**
   * Copyright text to display
   */
  copyright?: string;

  /**
   * Social media links
   */
  socialLinks?: SocialLink[];

  /**
   * Additional content to display above the copyright
   */
  bottomContent?: ReactNode;

  /**
   * Whether to show a border at the top
   * @default true
   */
  showBorder?: boolean;

  /**
   * Optional className for styling
   */
  className?: string;
} 

================================================
File: /src/components/layout/Header/Header.test.tsx
================================================
import { render, screen } from '@testing-library/react';
import { Header } from './Header';
import { HeaderProps } from './Header.types';

const mockHeaderProps: HeaderProps = {
  logo: <div>Logo</div>,
  navigation: [
    { label: 'Home', href: '/' },
    { label: 'About', href: '/about' },
  ],
  actions: (
    <>
      <a href="/login">Login</a>
      <a href="/signup">Sign Up</a>
    </>
  ),
};

const TestHeader = () => <Header {...mockHeaderProps} />;

TestHeader.displayName = 'TestHeader';

describe('Header', () => {
  it('renders logo, navigation and action items', () => {
    render(<TestHeader />);
    
    // Logo
    expect(screen.getByText('Logo')).toBeInTheDocument();
    
    // Navigation
    expect(screen.getByText('Home')).toBeInTheDocument();
    expect(screen.getByText('About')).toBeInTheDocument();
    
    // Actions
    expect(screen.getByText('Login')).toBeInTheDocument();
    expect(screen.getByText('Sign Up')).toBeInTheDocument();
  });
}); 

================================================
File: /src/components/layout/Header/Header.tsx
================================================
import { forwardRef } from 'react';
import Link from 'next/link';
import { HeaderProps } from './Header.types';
import { cn } from '@/lib/utils';

export const Header = forwardRef<HTMLElement, HeaderProps>(
  (
    {
      logo,
      navigation = [],
      actions,
      isSticky = true,
      showBorder = true,
      className,
      mobileMenuTrigger,
      isMobileMenuOpen = false,
      onMobileMenuToggle,
    },
    ref
  ) => {
    return (
      <header
        ref={ref}
        className={cn(
          'navbar navbar-expand-md bg-white',
          isSticky && 'sticky-top',
          showBorder && 'border-bottom',
          className
        )}
      >
        <div className="container">
          {/* Logo Section */}
          <div className="navbar-brand">
            {logo}
          </div>

          {/* Mobile Menu Button */}
          {mobileMenuTrigger && (
            <button
              type="button"
              className="navbar-toggler"
              onClick={() => onMobileMenuToggle?.(!isMobileMenuOpen)}
              aria-expanded={isMobileMenuOpen}
              aria-label="Toggle navigation"
            >
              {mobileMenuTrigger}
            </button>
          )}

          {/* Navigation and Actions */}
          <div className={`collapse navbar-collapse ${isMobileMenuOpen ? 'show' : ''}`}>
            {/* Desktop Navigation */}
            <nav className="navbar-nav me-auto mb-2 mb-md-0">
              {navigation.map(({ label, href, isExternal }) => (
                isExternal ? (
                  <a
                    key={href}
                    href={href}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="nav-link"
                  >
                    {label}
                  </a>
                ) : (
                  <Link
                    key={href}
                    href={href}
                    className="nav-link"
                  >
                    {label}
                  </Link>
                )
              ))}
            </nav>

            {/* Actions Section */}
            {actions && (
              <div className="d-flex">
                {actions}
              </div>
            )}
          </div>
        </div>
      </header>
    );
  }
);

Header.displayName = 'Header'; 

================================================
File: /src/components/layout/Header/Header.types.ts
================================================
import { ReactNode } from 'react';

export interface HeaderProps {
  /**
   * The site logo/brand element
   */
  logo?: ReactNode;

  /**
   * Navigation items to display
   */
  navigation?: {
    label: string;
    href: string;
    isExternal?: boolean;
  }[];

  /**
   * Actions to display in the header (e.g., login/signup buttons)
   */
  actions?: ReactNode;

  /**
   * Whether the header is sticky
   * @default true
   */
  isSticky?: boolean;

  /**
   * Whether to show a border at the bottom
   * @default true
   */
  showBorder?: boolean;

  /**
   * Optional className for styling
   */
  className?: string;

  /**
   * Optional mobile menu trigger element
   */
  mobileMenuTrigger?: ReactNode;

  /**
   * Whether the mobile menu is open
   * @default false
   */
  isMobileMenuOpen?: boolean;

  /**
   * Callback when mobile menu state changes
   */
  onMobileMenuToggle?: (isOpen: boolean) => void;
} 

================================================
File: /src/components/layout/Header/index.ts
================================================
export * from './Header';
export * from './Header.types'; 

================================================
File: /src/components/layout/MainLayout/MainLayout.test.tsx
================================================
import { render, screen } from '@/lib/test-utils';
import { MainLayout } from './MainLayout';

describe('MainLayout', () => {
  const defaultProps = {
    headerProps: {
      brandName: 'Test Brand',
      navItems: [{ label: 'Home', href: '/' }],
    },
    footerProps: {
      copyrightText: 'Test Copyright',
      links: [{ label: 'Privacy', href: '/privacy' }],
    },
    children: <div>Test Content</div>,
  };

  it('renders header, content, and footer', () => {
    render(<MainLayout {...defaultProps} />);
    
    // Check header
    expect(screen.getByText(defaultProps.headerProps.brandName)).toBeInTheDocument();
    expect(screen.getByText(defaultProps.headerProps.navItems[0].label)).toBeInTheDocument();
    
    // Check content
    expect(screen.getByText('Test Content')).toBeInTheDocument();
    
    // Check footer
    expect(screen.getByText(defaultProps.footerProps.copyrightText)).toBeInTheDocument();
    expect(screen.getByText(defaultProps.footerProps.links[0].label)).toBeInTheDocument();
  });

  it('renders with default header and footer props', () => {
    render(<MainLayout>{defaultProps.children}</MainLayout>);
    expect(screen.getByText('Test Content')).toBeInTheDocument();
    expect(screen.getByText('AI Tribes')).toBeInTheDocument();
  });
}); 

================================================
File: /src/components/layout/MainLayout/MainLayout.tsx
================================================
import { Header } from '../Header/Header';
import { Footer } from '../Footer/Footer';
import { MainLayoutProps } from './MainLayout.types';

export function MainLayout({ children, headerProps = {}, footerProps = {} }: MainLayoutProps) {
  return (
    <div className="d-flex flex-column min-vh-100">
      <Header {...headerProps} />
      <main className="flex-grow-1">
        {children}
      </main>
      <Footer {...footerProps} />
    </div>
  );
} 

================================================
File: /src/components/layout/MainLayout/MainLayout.types.ts
================================================
import { ReactNode } from 'react';
import { HeaderProps } from '../Header/Header.types';
import { FooterProps } from '../Footer/Footer.types';

export interface MainLayoutProps {
  children: ReactNode;
  headerProps?: HeaderProps;
  footerProps?: FooterProps;
} 

================================================
File: /src/components/shared/index.ts
================================================
// Shared components will be exported from here 

================================================
File: /src/components/ui/index.ts
================================================
export * from './Button/Button';
export * from './Input/Input';
export * from './Card/Card';
export * from './Modal/Modal';
export * from './Form/Form'; 

================================================
File: /src/components/ui/Button/Button.test.tsx
================================================
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  it('renders children correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('handles click events', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('displays loading state', () => {
    render(<Button isLoading>Click me</Button>);
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('displays custom loading text', () => {
    render(<Button isLoading loadingText="Please wait...">Click me</Button>);
    expect(screen.getByText('Please wait...')).toBeInTheDocument();
  });

  it('is disabled when loading', () => {
    render(<Button isLoading>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('is disabled when isDisabled is true', () => {
    render(<Button isDisabled>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('renders left icon', () => {
    render(
      <Button leftIcon={<span data-testid="left-icon">â†</span>}>
        Click me
      </Button>
    );
    expect(screen.getByTestId('left-icon')).toBeInTheDocument();
  });

  it('renders right icon', () => {
    render(
      <Button rightIcon={<span data-testid="right-icon">â†’</span>}>
        Click me
      </Button>
    );
    expect(screen.getByTestId('right-icon')).toBeInTheDocument();
  });

  it('applies full width class when isFullWidth is true', () => {
    render(<Button isFullWidth>Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('w-full');
  });

  it('applies variant classes correctly', () => {
    const { rerender } = render(<Button variant="primary">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-primary');

    rerender(<Button variant="secondary">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('bg-secondary');

    rerender(<Button variant="outline">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('border-input');

    rerender(<Button variant="ghost">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('hover:bg-accent');

    rerender(<Button variant="link">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('underline-offset-4');
  });

  it('applies size classes correctly', () => {
    const { rerender } = render(<Button size="sm">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('h-9');

    rerender(<Button size="md">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('h-10');

    rerender(<Button size="lg">Click me</Button>);
    expect(screen.getByRole('button')).toHaveClass('h-11');
  });
});


================================================
File: /src/components/ui/Button/Button.tsx
================================================
import { forwardRef } from 'react';
import { ButtonProps } from './Button.types';
import { cn } from '@/lib/utils';

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      variant = 'primary',
      size = 'md',
      isLoading = false,
      isDisabled = false,
      isFullWidth = false,
      children,
      leftIcon,
      rightIcon,
      loadingText = 'Loading...',
      className,
      ...props
    },
    ref
  ) => {
    const baseStyles = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50';

    const variants = {
      primary: 'bg-primary text-primary-foreground hover:bg-primary/90',
      secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
      outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
      ghost: 'hover:bg-accent hover:text-accent-foreground',
      link: 'text-primary underline-offset-4 hover:underline',
    };

    const sizes = {
      sm: 'h-9 px-3 text-sm',
      md: 'h-10 px-4 py-2',
      lg: 'h-11 px-8 text-lg',
    };

    return (
      <button
        ref={ref}
        disabled={isDisabled || isLoading}
        className={cn(
          baseStyles,
          variants[variant],
          sizes[size],
          isFullWidth && 'w-full',
          className
        )}
        {...props}
      >
        {isLoading ? (
          <>
            <svg
              className="mr-2 h-4 w-4 animate-spin"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
            {loadingText}
          </>
        ) : (
          <>
            {leftIcon && <span className="mr-2">{leftIcon}</span>}
            {children}
            {rightIcon && <span className="ml-2">{rightIcon}</span>}
          </>
        )}
      </button>
    );
  }
);

Button.displayName = 'Button';


================================================
File: /src/components/ui/Button/Button.types.ts
================================================
import { ButtonHTMLAttributes, ReactNode } from 'react';

export type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'ghost' | 'link';
export type ButtonSize = 'sm' | 'md' | 'lg';

export interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  /**
   * The visual style variant of the button
   * @default 'primary'
   */
  variant?: ButtonVariant;

  /**
   * The size of the button
   * @default 'md'
   */
  size?: ButtonSize;

  /**
   * Whether the button is in a loading state
   * @default false
   */
  isLoading?: boolean;

  /**
   * Whether the button is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the button takes up the full width of its container
   * @default false
   */
  isFullWidth?: boolean;

  /**
   * The content of the button
   */
  children: ReactNode;

  /**
   * Optional left icon
   */
  leftIcon?: ReactNode;

  /**
   * Optional right icon
   */
  rightIcon?: ReactNode;

  /**
   * Optional loading text
   * @default 'Loading...'
   */
  loadingText?: string;
}


================================================
File: /src/components/ui/Button/index.ts
================================================
export * from './Button';
export * from './Button.types';


================================================
File: /src/components/ui/Card/Card.module.css
================================================
.card {
  transition: transform 0.2s ease-in-out;
}

.card:hover {
  transform: translateY(-5px);
} 

================================================
File: /src/components/ui/Card/Card.test.tsx
================================================
import { render, screen } from '@/lib/test-utils';
import { ExampleCard } from './Card';

describe('ExampleCard', () => {
  const defaultProps = {
    title: 'Test Title',
    description: 'Test Description',
    ctaText: 'Learn More',
    ctaHref: '#test',
  };

  it('renders all provided content', () => {
    render(<ExampleCard {...defaultProps} />);

    expect(screen.getByText(defaultProps.title)).toBeInTheDocument();
    expect(screen.getByText(defaultProps.description)).toBeInTheDocument();
    expect(screen.getByText(defaultProps.ctaText)).toBeInTheDocument();
    expect(screen.getByRole('link')).toHaveAttribute('href', defaultProps.ctaHref);
  });

  it('applies hover styles correctly', () => {
    render(<ExampleCard {...defaultProps} />);
    const card = screen.getByRole('link').closest('.card');
    expect(card).toHaveClass('card');
  });
}); 

================================================
File: /src/components/ui/Card/Card.tsx
================================================
import { ExampleCardProps } from './Card.types';
import Link from 'next/link';

export function ExampleCard({ title, description, ctaText, ctaHref }: ExampleCardProps) {
  return (
    <div className="card h-100">
      <div className="card-body">
        <h3 className="card-title">{title}</h3>
        <p className="card-text">{description}</p>
        <Link 
          href={ctaHref}
          className="btn btn-primary d-inline-flex align-items-center"
        >
          {ctaText}
          <svg
            className="ms-2"
            style={{ width: '1rem', height: '1rem' }}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 5l7 7-7 7"
            />
          </svg>
        </Link>
      </div>
    </div>
  );
} 

================================================
File: /src/components/ui/Card/Card.types.ts
================================================
export interface ExampleCardProps {
  title: string;
  description: string;
  ctaText: string;
  ctaHref: string;
} 

================================================
File: /src/components/ui/Card/index.ts
================================================
export * from './Card';
export * from './Card.types'; 

================================================
File: /src/components/ui/Form/Form.integration.test.tsx
================================================
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Form, FormField, FormGroup } from './';
import { Input } from '../Input';
import { Button } from '../Button';

describe('Form Integration', () => {
  describe('Form with FormField', () => {
    it('submits form with field values', async () => {
      const handleSubmit = jest.fn();
      render(
        <Form onSubmit={handleSubmit}>
          <FormField name="username" label="Username">
            <Input defaultValue="testuser" />
          </FormField>
          <Button type="submit">Submit</Button>
        </Form>
      );

      fireEvent.click(screen.getByText('Submit'));
      await waitFor(() => {
        expect(handleSubmit).toHaveBeenCalledWith(
          expect.objectContaining({
            username: 'testuser',
          })
        );
      });
    });

    it('handles multiple fields in a form', async () => {
      const handleSubmit = jest.fn();
      render(
        <Form onSubmit={handleSubmit}>
          <FormField name="username" label="Username">
            <Input defaultValue="testuser" />
          </FormField>
          <FormField name="email" label="Email">
            <Input defaultValue="test@example.com" type="email" />
          </FormField>
          <Button type="submit">Submit</Button>
        </Form>
      );

      fireEvent.click(screen.getByText('Submit'));
      await waitFor(() => {
        expect(handleSubmit).toHaveBeenCalledWith(
          expect.objectContaining({
            username: 'testuser',
            email: 'test@example.com',
          })
        );
      });
    });

    it('prevents submission when form is loading', async () => {
      const handleSubmit = jest.fn();
      render(
        <Form onSubmit={handleSubmit} isLoading>
          <FormField name="username" label="Username">
            <Input defaultValue="testuser" />
          </FormField>
          <Button type="submit">Submit</Button>
        </Form>
      );

      fireEvent.click(screen.getByText('Submit'));
      await waitFor(() => {
        expect(handleSubmit).not.toHaveBeenCalled();
      });
    });
  });

  describe('Form with FormGroup', () => {
    it('renders fields in horizontal layout', () => {
      render(
        <Form onSubmit={() => {}}>
          <FormGroup direction="horizontal">
            <FormField name="firstName" label="First Name">
              <Input placeholder="First name" />
            </FormField>
            <FormField name="lastName" label="Last Name">
              <Input placeholder="Last name" />
            </FormField>
          </FormGroup>
        </Form>
      );

      const group = screen.getByPlaceholderText('First name').closest('.flex');
      expect(group).toHaveClass('items-center');
    });

    it('handles nested groups with different layouts', () => {
      render(
        <Form onSubmit={() => {}}>
          <FormGroup>
            <FormField name="email" label="Email">
              <Input type="email" />
            </FormField>
            <FormGroup direction="horizontal">
              <FormField name="password" label="Password">
                <Input type="password" />
              </FormField>
              <FormField name="confirmPassword" label="Confirm Password">
                <Input type="password" />
              </FormField>
            </FormGroup>
          </FormGroup>
        </Form>
      );

      const verticalGroup = screen.getByLabelText('Email').closest('.space-y-4');
      const horizontalGroup = screen.getByLabelText('Password').closest('.flex');
      
      expect(verticalGroup).toBeInTheDocument();
      expect(horizontalGroup).toHaveClass('items-center');
    });
  });

  describe('Form Error Handling', () => {
    it('displays form-level error message', () => {
      render(
        <Form onSubmit={() => {}} error="Invalid credentials">
          <FormField name="username">
            <Input />
          </FormField>
        </Form>
      );

      expect(screen.getByText('Invalid credentials')).toBeInTheDocument();
    });

    it('displays field-level error messages', () => {
      render(
        <Form onSubmit={() => {}}>
          <FormField 
            name="username" 
            error="Username is required"
          >
            <Input />
          </FormField>
          <FormField 
            name="email" 
            error="Invalid email format"
          >
            <Input type="email" />
          </FormField>
        </Form>
      );

      expect(screen.getByText('Username is required')).toBeInTheDocument();
      expect(screen.getByText('Invalid email format')).toBeInTheDocument();
    });

    it('handles async form submission errors', async () => {
      const handleSubmit = jest.fn().mockRejectedValue(new Error('Submission failed'));
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation(() => {});

      render(
        <Form onSubmit={handleSubmit}>
          <FormField name="username">
            <Input defaultValue="testuser" />
          </FormField>
          <Button type="submit">Submit</Button>
        </Form>
      );

      fireEvent.click(screen.getByText('Submit'));
      await waitFor(() => {
        expect(handleSubmit).toHaveBeenCalled();
      });

      consoleSpy.mockRestore();
    });
  });

  describe('Form Accessibility', () => {
    it('maintains proper tab order', () => {
      render(
        <Form onSubmit={() => {}}>
          <FormField name="username" label="Username">
            <Input />
          </FormField>
          <FormField name="password" label="Password">
            <Input type="password" />
          </FormField>
          <Button type="submit">Submit</Button>
        </Form>
      );

      const elements = [
        screen.getByLabelText('Username'),
        screen.getByLabelText('Password'),
        screen.getByText('Submit'),
      ];

      elements.forEach((element, index) => {
        expect(element).toHaveAttribute('tabIndex', index === 2 ? undefined : '0');
      });
    });

    it('associates labels with inputs correctly', () => {
      render(
        <Form onSubmit={() => {}}>
          <FormField name="username" label="Username">
            <Input />
          </FormField>
        </Form>
      );

      const input = screen.getByLabelText('Username');
      const label = screen.getByText('Username');
      
      expect(input).toHaveAttribute('id', 'username');
      expect(label).toHaveAttribute('for', 'username');
    });
  });
}); 

================================================
File: /src/components/ui/Form/Form.test.tsx
================================================
import { render, screen, fireEvent } from '@testing-library/react';
import { Form, FormField, FormGroup } from './';
import { Input } from '../Input';

describe('Form Components', () => {
  describe('Form', () => {
    const mockSubmit = jest.fn();
    const defaultProps = {
      onSubmit: mockSubmit,
    };

    beforeEach(() => {
      mockSubmit.mockClear();
    });

    it('renders children correctly', () => {
      render(
        <Form {...defaultProps}>
          <div>Form Content</div>
        </Form>
      );
      expect(screen.getByText('Form Content')).toBeInTheDocument();
    });

    it('shows error message when provided', () => {
      render(
        <Form {...defaultProps} error="Form submission failed">
          <div>Form Content</div>
        </Form>
      );
      expect(screen.getByText('Form submission failed')).toBeInTheDocument();
    });

    it('shows success message when provided', () => {
      render(
        <Form {...defaultProps} success="Form submitted successfully">
          <div>Form Content</div>
        </Form>
      );
      expect(screen.getByText('Form submitted successfully')).toBeInTheDocument();
    });

    it('calls onSubmit with form data', () => {
      render(
        <Form {...defaultProps}>
          <Input name="username" defaultValue="testuser" />
          <button type="submit">Submit</button>
        </Form>
      );

      fireEvent.submit(screen.getByRole('form'));
      expect(mockSubmit).toHaveBeenCalledWith(expect.objectContaining({
        username: 'testuser',
      }));
    });

    it('prevents submission when isLoading is true', () => {
      render(
        <Form {...defaultProps} isLoading>
          <button type="submit">Submit</button>
        </Form>
      );
      fireEvent.submit(screen.getByRole('form'));
      expect(mockSubmit).not.toHaveBeenCalled();
    });
  });

  describe('FormField', () => {
    it('renders label correctly', () => {
      render(
        <FormField name="username" label="Username">
          <Input />
        </FormField>
      );
      expect(screen.getByText('Username')).toBeInTheDocument();
    });

    it('shows required indicator when isRequired is true', () => {
      render(
        <FormField name="username" label="Username" isRequired>
          <Input />
        </FormField>
      );
      expect(screen.getByText('*')).toBeInTheDocument();
    });

    it('shows error message when provided', () => {
      render(
        <FormField name="username" error="This field is required">
          <Input />
        </FormField>
      );
      expect(screen.getByText('This field is required')).toBeInTheDocument();
    });

    it('shows helper text when provided', () => {
      render(
        <FormField name="username" helperText="Enter your username">
          <Input />
        </FormField>
      );
      expect(screen.getByText('Enter your username')).toBeInTheDocument();
    });
  });

  describe('FormGroup', () => {
    it('renders children correctly', () => {
      render(
        <FormGroup>
          <div>Field 1</div>
          <div>Field 2</div>
        </FormGroup>
      );
      expect(screen.getByText('Field 1')).toBeInTheDocument();
      expect(screen.getByText('Field 2')).toBeInTheDocument();
    });

    it('applies vertical direction classes by default', () => {
      render(
        <FormGroup>
          <div>Field 1</div>
          <div>Field 2</div>
        </FormGroup>
      );
      expect(screen.getByText('Field 1').parentElement).toHaveClass('space-y-4');
    });

    it('applies horizontal direction classes when specified', () => {
      render(
        <FormGroup direction="horizontal">
          <div>Field 1</div>
          <div>Field 2</div>
        </FormGroup>
      );
      expect(screen.getByText('Field 1').parentElement).toHaveClass('flex', 'items-center');
    });

    it('applies full width class when isFullWidth is true', () => {
      render(
        <FormGroup isFullWidth>
          <div>Field 1</div>
        </FormGroup>
      );
      expect(screen.getByText('Field 1').parentElement).toHaveClass('w-full');
    });
  });
}); 

================================================
File: /src/components/ui/Form/Form.tsx
================================================
import { forwardRef } from 'react';
import { FormProps } from './Form.types';
import { cn } from '@/lib/utils';

export const Form = forwardRef<HTMLFormElement, FormProps>(
  (
    {
      children,
      className,
      isLoading = false,
      isDisabled = false,
      error,
      success,
      onSubmit,
      ...props
    },
    ref
  ) => {
    const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
      event.preventDefault();
      if (isLoading || isDisabled) return;

      const formData = new FormData(event.currentTarget);
      const data = Object.fromEntries(formData.entries());

      try {
        await onSubmit(data);
      } catch (error) {
        console.error('Form submission error:', error);
      }
    };

    return (
      <form
        ref={ref}
        className={cn('space-y-6', className)}
        onSubmit={handleSubmit}
        {...props}
      >
        <div className="space-y-4">
          {error && (
            <div className="rounded-md bg-destructive/15 p-3 text-sm text-destructive">
              {error}
            </div>
          )}
          {success && (
            <div className="rounded-md bg-success/15 p-3 text-sm text-success">
              {success}
            </div>
          )}
          {children}
        </div>
      </form>
    );
  }
);

Form.displayName = 'Form'; 

================================================
File: /src/components/ui/Form/Form.types.ts
================================================
import { FormEvent, FormHTMLAttributes, ReactElement, ReactNode } from 'react';

export interface FormProps<TFormData = Record<string, unknown>> extends Omit<FormHTMLAttributes<HTMLFormElement>, 'onSubmit'> {
  /**
   * Whether the form is in a loading state
   * @default false
   */
  isLoading?: boolean;

  /**
   * Whether the form is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * The error message to display
   */
  error?: string;

  /**
   * The success message to display
   */
  success?: string;

  /**
   * Form submission handler
   */
  onSubmit: (data: TFormData, event: FormEvent<HTMLFormElement>) => void | Promise<void>;
}

export interface FieldProps {
  id: string;
  name: string;
  'aria-describedby'?: string;
  isRequired?: boolean;
  error?: string;
}

export interface FormFieldProps {
  /**
   * The name of the field
   */
  name: string;

  /**
   * The label for the field
   */
  label?: string;

  /**
   * Whether the field is required
   * @default false
   */
  isRequired?: boolean;

  /**
   * The error message to display
   */
  error?: string;

  /**
   * Helper text to display below the field
   */
  helperText?: string;

  /**
   * The children components (usually Input, Select, etc.)
   */
  children: ReactElement<FieldProps>;

  /**
   * Optional className for styling
   */
  className?: string;
}

export interface FormGroupProps {
  /**
   * The children components
   */
  children: ReactNode;

  /**
   * The direction of the group
   * @default 'vertical'
   */
  direction?: 'horizontal' | 'vertical';

  /**
   * The spacing between items
   * @default 'md'
   */
  spacing?: 'sm' | 'md' | 'lg';

  /**
   * Whether the group should take up the full width
   * @default false
   */
  isFullWidth?: boolean;

  /**
   * Optional className for styling
   */
  className?: string;
} 

================================================
File: /src/components/ui/Form/FormField.test.tsx
================================================
import { render, screen } from '@testing-library/react';
import { FormField } from './FormField';
import { Input } from '../Input';

describe('FormField', () => {
  const defaultProps = {
    name: 'test-field',
    children: <Input placeholder="Test input" />,
  };

  it('renders input with correct props', () => {
    render(<FormField {...defaultProps} />);
    const input = screen.getByPlaceholderText('Test input');
    expect(input).toHaveAttribute('id', 'test-field');
    expect(input).toHaveAttribute('name', 'test-field');
  });

  it('renders label when provided', () => {
    render(<FormField {...defaultProps} label="Test Label" />);
    expect(screen.getByText('Test Label')).toBeInTheDocument();
  });

  it('shows required indicator when isRequired is true', () => {
    render(<FormField {...defaultProps} label="Test Label" isRequired />);
    const label = screen.getByText('Test Label');
    expect(label.parentElement).toContainElement(screen.getByText('*'));
  });

  it('shows error message when provided', () => {
    const errorMessage = 'This field is required';
    render(<FormField {...defaultProps} error={errorMessage} />);
    
    const errorText = screen.getByText(errorMessage);
    expect(errorText).toBeInTheDocument();
    expect(errorText).toHaveClass('text-destructive');
  });

  it('shows helper text when provided', () => {
    const helperText = 'Enter your username';
    render(<FormField {...defaultProps} helperText={helperText} />);
    
    const helperElement = screen.getByText(helperText);
    expect(helperElement).toBeInTheDocument();
    expect(helperElement).not.toHaveClass('text-destructive');
  });

  it('sets aria-describedby correctly with error', () => {
    render(<FormField {...defaultProps} error="Error message" />);
    const input = screen.getByPlaceholderText('Test input');
    expect(input).toHaveAttribute('aria-describedby', 'test-field-error');
  });

  it('sets aria-describedby correctly with helper text', () => {
    render(<FormField {...defaultProps} helperText="Helper text" />);
    const input = screen.getByPlaceholderText('Test input');
    expect(input).toHaveAttribute('aria-describedby', 'test-field-helper');
  });

  it('applies custom className to wrapper', () => {
    render(<FormField {...defaultProps} className="custom-class" />);
    const wrapper = screen.getByPlaceholderText('Test input').parentElement?.parentElement;
    expect(wrapper).toHaveClass('custom-class');
  });

  it('prioritizes error message over helper text', () => {
    render(
      <FormField
        {...defaultProps}
        error="Error message"
        helperText="Helper text"
      />
    );
    
    expect(screen.getByText('Error message')).toBeInTheDocument();
    expect(screen.queryByText('Helper text')).not.toBeInTheDocument();
  });

  it('passes isRequired to input component', () => {
    render(<FormField {...defaultProps} isRequired />);
    const input = screen.getByPlaceholderText('Test input');
    expect(input).toHaveAttribute('aria-required', 'true');
  });

  it('handles non-input children gracefully', () => {
    render(
      <FormField name="test-field">
        <div data-testid="custom-child">Custom child</div>
      </FormField>
    );
    
    expect(screen.getByTestId('custom-child')).toBeInTheDocument();
  });
}); 

================================================
File: /src/components/ui/Form/FormField.tsx
================================================
import { forwardRef, isValidElement, cloneElement } from 'react';
import { FormFieldProps, FieldProps } from './Form.types';
import { cn } from '@/lib/utils';

export const FormField = forwardRef<HTMLDivElement, FormFieldProps>(
  (
    {
      name,
      label,
      error,
      helperText,
      isRequired = false,
      children,
      className,
      ...props
    },
    ref
  ) => {
    // Clone child element to pass down field props
    const field = isValidElement(children)
      ? cloneElement<FieldProps>(children, {
          id: name,
          name,
          'aria-describedby': error ? `${name}-error` : helperText ? `${name}-helper` : undefined,
          isRequired,
          error,
        })
      : children;

    return (
      <div ref={ref} className={cn("w-full space-y-2", className)} {...props}>
        {label && (
          <label
            htmlFor={name}
            className={cn(
              'text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70'
            )}
          >
            {label}
            {isRequired && <span className="text-destructive">*</span>}
          </label>
        )}
        {field}
        {(error || helperText) && (
          <p
            className={cn(
              'text-sm',
              error ? 'text-destructive' : 'text-muted-foreground'
            )}
            id={error ? `${name}-error` : `${name}-helper`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    );
  }
);

FormField.displayName = 'FormField'; 

================================================
File: /src/components/ui/Form/FormGroup.tsx
================================================
import { forwardRef } from 'react';
import { FormGroupProps } from './Form.types';
import { cn } from '@/lib/utils';

export const FormGroup = forwardRef<HTMLDivElement, FormGroupProps>(
  (
    {
      children,
      direction = 'vertical',
      spacing = 'md',
      isFullWidth = false,
      className,
      ...props
    },
    ref
  ) => {
    const spacingClasses = {
      sm: 'space-y-2',
      md: 'space-y-4',
      lg: 'space-y-6',
    };

    const directionClasses = {
      vertical: spacingClasses[spacing],
      horizontal: cn(
        'flex items-center',
        {
          'gap-2': spacing === 'sm',
          'gap-4': spacing === 'md',
          'gap-6': spacing === 'lg',
        }
      ),
    };

    return (
      <div
        ref={ref}
        className={cn(
          directionClasses[direction],
          isFullWidth && 'w-full',
          className
        )}
        {...props}
      >
        {children}
      </div>
    );
  }
);

FormGroup.displayName = 'FormGroup'; 

================================================
File: /src/components/ui/Form/index.ts
================================================
export * from './Form';
export * from './FormField';
export * from './FormGroup';
export * from './Form.types'; 

================================================
File: /src/components/ui/Input/Input.test.tsx
================================================
import { render, screen, fireEvent } from '@testing-library/react';
import { Input } from './Input';

describe('Input', () => {
  it('renders correctly', () => {
    render(<Input placeholder="Enter text" />);
    expect(screen.getByPlaceholderText('Enter text')).toBeInTheDocument();
  });

  it('renders label when provided', () => {
    render(<Input label="Username" />);
    expect(screen.getByText('Username')).toBeInTheDocument();
  });

  it('shows required indicator when isRequired is true', () => {
    render(<Input label="Username" isRequired />);
    expect(screen.getByText('*')).toBeInTheDocument();
  });

  it('shows error message when error is provided', () => {
    render(<Input error="This field is required" />);
    expect(screen.getByText('This field is required')).toBeInTheDocument();
  });

  it('shows helper text when provided', () => {
    render(<Input helperText="Must be at least 8 characters" />);
    expect(screen.getByText('Must be at least 8 characters')).toBeInTheDocument();
  });

  it('handles value changes', () => {
    const handleChange = jest.fn();
    render(<Input onChange={handleChange} />);
    
    const input = screen.getByRole('textbox');
    fireEvent.change(input, { target: { value: 'test' } });
    
    expect(handleChange).toHaveBeenCalled();
  });

  it('can be disabled', () => {
    render(<Input isDisabled />);
    expect(screen.getByRole('textbox')).toBeDisabled();
  });

  it('can be readonly', () => {
    render(<Input isReadOnly />);
    expect(screen.getByRole('textbox')).toHaveAttribute('readonly');
  });

  it('renders left element when provided', () => {
    render(
      <Input
        leftElement={<span data-testid="left-element">@</span>}
        placeholder="Username"
      />
    );
    expect(screen.getByTestId('left-element')).toBeInTheDocument();
  });

  it('renders right element when provided', () => {
    render(
      <Input
        rightElement={<span data-testid="right-element">âœ“</span>}
        placeholder="Username"
      />
    );
    expect(screen.getByTestId('right-element')).toBeInTheDocument();
  });

  it('applies variant classes correctly', () => {
    const { rerender } = render(<Input variant="outline" />);
    expect(screen.getByRole('textbox')).toHaveClass('border-input');

    rerender(<Input variant="filled" />);
    expect(screen.getByRole('textbox')).toHaveClass('bg-secondary');

    rerender(<Input variant="flushed" />);
    expect(screen.getByRole('textbox')).toHaveClass('rounded-none');

    rerender(<Input variant="unstyled" />);
    expect(screen.getByRole('textbox')).toHaveClass('border-none');
  });

  it('applies size classes correctly', () => {
    const { rerender } = render(<Input size="sm" />);
    expect(screen.getByRole('textbox')).toHaveClass('h-8');

    rerender(<Input size="md" />);
    expect(screen.getByRole('textbox')).toHaveClass('h-10');

    rerender(<Input size="lg" />);
    expect(screen.getByRole('textbox')).toHaveClass('h-12');
  });

  it('applies error styles when isInvalid is true', () => {
    render(<Input isInvalid />);
    expect(screen.getByRole('textbox')).toHaveClass('border-destructive');
  });
}); 

================================================
File: /src/components/ui/Input/Input.tsx
================================================
import { forwardRef } from 'react';
import { InputProps } from './Input.types';
import { cn } from '@/lib/utils';

export const Input = forwardRef<HTMLInputElement, InputProps>(
  (
    {
      className,
      variant = 'outline',
      size = 'md',
      error,
      helperText,
      label,
      isInvalid,
      isDisabled,
      isRequired,
      isReadOnly,
      leftElement,
      rightElement,
      id,
      ...props
    },
    ref
  ) => {
    const baseStyles = 'flex w-full rounded-md border bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50';

    const variants = {
      outline: 'border-input',
      filled: 'border-transparent bg-secondary',
      flushed: 'rounded-none border-b border-t-0 border-x-0 px-0',
      unstyled: 'border-none px-0 shadow-none focus-visible:ring-0 focus-visible:ring-offset-0',
    };

    const sizes = {
      sm: 'h-8 text-xs',
      md: 'h-10 text-sm',
      lg: 'h-12 text-base px-4',
    };

    const inputId = id || label?.toLowerCase().replace(/\s+/g, '-');

    return (
      <div className="w-full">
        {label && (
          <label
            htmlFor={inputId}
            className={cn(
              'mb-2 block text-sm font-medium',
              isDisabled && 'opacity-50'
            )}
          >
            {label}
            {isRequired && <span className="text-destructive">*</span>}
          </label>
        )}
        <div className="relative">
          {leftElement && (
            <div className="absolute inset-y-0 left-0 flex items-center pl-3">
              {leftElement}
            </div>
          )}
          <input
            ref={ref}
            id={inputId}
            disabled={isDisabled}
            readOnly={isReadOnly}
            aria-invalid={isInvalid}
            aria-required={isRequired}
            className={cn(
              baseStyles,
              variants[variant],
              sizes[size],
              leftElement && 'pl-10',
              rightElement && 'pr-10',
              isInvalid && 'border-destructive focus-visible:ring-destructive',
              className
            )}
            {...props}
          />
          {rightElement && (
            <div className="absolute inset-y-0 right-0 flex items-center pr-3">
              {rightElement}
            </div>
          )}
        </div>
        {(error || helperText) && (
          <p
            className={cn(
              'mt-2 text-sm',
              error ? 'text-destructive' : 'text-muted-foreground'
            )}
          >
            {error || helperText}
          </p>
        )}
      </div>
    );
  }
);

Input.displayName = 'Input'; 

================================================
File: /src/components/ui/Input/Input.types.ts
================================================
import { InputHTMLAttributes, ReactNode } from 'react';
import { FieldProps } from '../Form/Form.types';

export type InputSize = 'sm' | 'md' | 'lg';
export type InputVariant = 'outline' | 'filled' | 'flushed' | 'unstyled';

export interface InputProps extends Omit<InputHTMLAttributes<HTMLInputElement>, 'size'>, 
  Pick<FieldProps, 'error' | 'isRequired'> {
  /**
   * The size of the input
   * @default 'md'
   */
  size?: InputSize;

  /**
   * The variant of the input
   * @default 'outline'
   */
  variant?: InputVariant;

  /**
   * Whether the input is invalid
   * @default false
   */
  isInvalid?: boolean;

  /**
   * Whether the input is disabled
   * @default false
   */
  isDisabled?: boolean;

  /**
   * Whether the input is read only
   * @default false
   */
  isReadOnly?: boolean;

  /**
   * Helper text to display below the input
   */
  helperText?: string;

  /**
   * Label for the input
   */
  label?: string;

  /**
   * Optional left element (icon, text, etc.)
   */
  leftElement?: ReactNode;

  /**
   * Optional right element (icon, text, etc.)
   */
  rightElement?: ReactNode;
} 

================================================
File: /src/components/ui/Input/index.ts
================================================
export * from './Input';
export * from './Input.types'; 

================================================
File: /src/components/ui/Modal/Modal.test.tsx
================================================
import { render, screen, fireEvent } from '@testing-library/react';
import { Modal } from './Modal';

describe('Modal', () => {
  const defaultProps = {
    isOpen: true,
    onClose: jest.fn(),
    title: 'Test Modal',
  };

  beforeEach(() => {
    defaultProps.onClose.mockClear();
  });

  it('renders when isOpen is true', () => {
    render(
      <Modal {...defaultProps}>
        <div>Modal Content</div>
      </Modal>
    );
    expect(screen.getByText('Test Modal')).toBeInTheDocument();
    expect(screen.getByText('Modal Content')).toBeInTheDocument();
  });

  it('does not render when isOpen is false', () => {
    render(
      <Modal {...defaultProps} isOpen={false}>
        <div>Modal Content</div>
      </Modal>
    );
    expect(screen.queryByText('Test Modal')).not.toBeInTheDocument();
    expect(screen.queryByText('Modal Content')).not.toBeInTheDocument();
  });

  it('calls onClose when close button is clicked', () => {
    render(
      <Modal {...defaultProps}>
        <div>Modal Content</div>
      </Modal>
    );
    fireEvent.click(screen.getByRole('button', { name: /close/i }));
    expect(defaultProps.onClose).toHaveBeenCalledTimes(1);
  });

  it('calls onClose when clicking outside the modal', () => {
    render(
      <Modal {...defaultProps}>
        <div>Modal Content</div>
      </Modal>
    );
    fireEvent.click(screen.getByTestId('modal-backdrop'));
    expect(defaultProps.onClose).toHaveBeenCalledTimes(1);
  });

  it('renders footer content when provided', () => {
    render(
      <Modal {...defaultProps} footer={<button>Save</button>}>
        <div>Modal Content</div>
      </Modal>
    );
    expect(screen.getByRole('button', { name: 'Save' })).toBeInTheDocument();
  });

  it('prevents backdrop click when preventClose is true', () => {
    render(
      <Modal {...defaultProps} preventClose>
        <div>Modal Content</div>
      </Modal>
    );
    fireEvent.click(screen.getByTestId('modal-backdrop'));
    expect(defaultProps.onClose).not.toHaveBeenCalled();
  });

  it('applies custom size class when provided', () => {
    render(
      <Modal {...defaultProps} size="lg">
        <div>Modal Content</div>
      </Modal>
    );
    expect(screen.getByRole('dialog')).toHaveClass('max-w-4xl');
  });

  it('renders with custom className when provided', () => {
    render(
      <Modal {...defaultProps} className="custom-modal">
        <div>Modal Content</div>
      </Modal>
    );
    expect(screen.getByRole('dialog')).toHaveClass('custom-modal');
  });

  it('renders with custom contentClassName when provided', () => {
    render(
      <Modal {...defaultProps} contentClassName="custom-content">
        <div>Modal Content</div>
      </Modal>
    );
    expect(screen.getByTestId('modal-content')).toHaveClass('custom-content');
  });
}); 

================================================
File: /src/components/ui/Modal/Modal.tsx
================================================
import { useEffect } from 'react';
import { createPortal } from 'react-dom';
import { ModalProps } from './Modal.types';
import { cn } from '@/lib/utils';

const sizeClasses = {
  sm: 'max-w-sm',
  md: 'max-w-2xl',
  lg: 'max-w-4xl',
  xl: 'max-w-6xl',
};

export const Modal = ({
  isOpen,
  onClose,
  title,
  children,
  footer,
  size = 'md',
  preventClose = false,
  className,
  contentClassName,
}: ModalProps) => {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && !preventClose) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose, preventClose]);

  if (!isOpen) return null;

  const handleBackdropClick = (e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !preventClose) {
      onClose();
    }
  };

  const modalContent = (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/50"
      onClick={handleBackdropClick}
      data-testid="modal-backdrop"
    >
      <div
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        className={cn(
          'relative mx-4 rounded-lg bg-white shadow-xl',
          sizeClasses[size],
          className
        )}
      >
        <div className={cn('p-6', contentClassName)} data-testid="modal-content">
          <div className="mb-4 flex items-center justify-between">
            <h2 id="modal-title" className="text-xl font-semibold">
              {title}
            </h2>
            <button
              type="button"
              onClick={onClose}
              className="text-gray-400 hover:text-gray-500"
              aria-label="close"
            >
              <svg
                className="h-6 w-6"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </button>
          </div>
          <div className="mb-6">{children}</div>
          {footer && <div className="mt-6 flex justify-end">{footer}</div>}
        </div>
      </div>
    </div>
  );

  return createPortal(modalContent, document.body);
}; 

================================================
File: /src/components/ui/Modal/Modal.types.ts
================================================
export interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  title?: string;
  children: React.ReactNode;
  className?: string;
} 

================================================
File: /src/components/ui/Modal/index.ts
================================================
export * from './Modal';
export * from './Modal.types'; 

================================================
File: /src/lib/test-utils.tsx
================================================
import { render, RenderOptions } from '@testing-library/react';
import { ReactElement } from 'react';

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { ...options });

export * from '@testing-library/react';
export { customRender as render }; 

================================================
File: /src/lib/utils.ts
================================================
import { clsx, type ClassValue } from 'clsx';

/**
 * Combines class names using clsx
 * This ensures proper handling of conditional classes
 */
export function cn(...inputs: ClassValue[]) {
  return clsx(inputs);
} 

================================================
File: /src/lib/api/client.ts
================================================
import { ApiError, ApiRequestConfig, ApiResponse, HttpMethod } from './types';

class ApiClient {
  private config: ApiRequestConfig;

  constructor(config: ApiRequestConfig = {}) {
    this.config = {
      baseURL: process.env.NEXT_PUBLIC_API_URL || '/api',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
      ...config,
    };
  }

  private async request<T, D = unknown>(
    method: HttpMethod,
    endpoint: string,
    data?: D,
    config: Partial<ApiRequestConfig> = {}
  ): Promise<ApiResponse<T>> {
    const url = `${this.config.baseURL}${endpoint}`;
    const headers = { ...this.config.headers, ...config.headers };

    try {
      const response = await fetch(url, {
        method,
        headers,
        body: data ? JSON.stringify(data) : undefined,
        signal: AbortSignal.timeout(config.timeout || this.config.timeout || 10000),
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw {
          code: response.status.toString(),
          message: responseData.message || 'An error occurred',
          details: responseData.details,
        } as ApiError;
      }

      return { data: responseData };
    } catch (error) {
      const apiError = error as ApiError;
      return {
        error: {
          code: apiError.code || 'UNKNOWN_ERROR',
          message: apiError.message || 'An unknown error occurred',
          details: apiError.details,
        },
      };
    }
  }

  public async get<T>(endpoint: string, config?: Partial<ApiRequestConfig>): Promise<ApiResponse<T>> {
    return this.request<T>('GET', endpoint, undefined, config);
  }

  public async post<T, D = unknown>(endpoint: string, data?: D, config?: Partial<ApiRequestConfig>): Promise<ApiResponse<T>> {
    return this.request<T, D>('POST', endpoint, data, config);
  }

  public async put<T, D = unknown>(endpoint: string, data?: D, config?: Partial<ApiRequestConfig>): Promise<ApiResponse<T>> {
    return this.request<T, D>('PUT', endpoint, data, config);
  }

  public async delete<T>(endpoint: string, config?: Partial<ApiRequestConfig>): Promise<ApiResponse<T>> {
    return this.request<T>('DELETE', endpoint, undefined, config);
  }

  public async patch<T, D = unknown>(endpoint: string, data?: D, config?: Partial<ApiRequestConfig>): Promise<ApiResponse<T>> {
    return this.request<T, D>('PATCH', endpoint, data, config);
  }

  public setHeader(key: string, value: string): void {
    this.config.headers = {
      ...this.config.headers,
      [key]: value,
    };
  }

  public removeHeader(key: string): void {
    if (this.config.headers) {
      delete this.config.headers[key];
    }
  }
}

export const api = new ApiClient(); 

================================================
File: /src/lib/api/constants.ts
================================================
export const API_ENDPOINTS = {
  AUTH: {
    LOGIN: '/auth/login',
    REGISTER: '/auth/register',
    LOGOUT: '/auth/logout',
    REFRESH: '/auth/refresh',
    ME: '/auth/me',
  },
  TRIBES: {
    LIST: '/tribes',
    CREATE: '/tribes',
    GET: (id: string) => `/tribes/${id}`,
    UPDATE: (id: string) => `/tribes/${id}`,
    DELETE: (id: string) => `/tribes/${id}`,
  },
  AGENTS: {
    LIST: '/agents',
    CREATE: '/agents',
    GET: (id: string) => `/agents/${id}`,
    UPDATE: (id: string) => `/agents/${id}`,
    DELETE: (id: string) => `/agents/${id}`,
  },
} as const;

export const API_ERROR_CODES = {
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  NOT_FOUND: 'NOT_FOUND',
  VALIDATION_ERROR: 'VALIDATION_ERROR',
  INTERNAL_ERROR: 'INTERNAL_ERROR',
} as const;

export const DEFAULT_API_CONFIG = {
  timeout: 10000,
  retries: 3,
  retryDelay: 1000,
} as const; 

================================================
File: /src/lib/api/hooks.ts
================================================
import { useState, useCallback } from 'react';
import { ApiResponse, ApiError } from './types';
import { api } from './client';

interface UseApiState<T> {
  data: T | null;
  error: ApiError | null;
  isLoading: boolean;
}

interface UseApiResponse<T, Args extends unknown[] = unknown[]> extends UseApiState<T> {
  execute: (...args: Args) => Promise<void>;
  reset: () => void;
}

export function useApi<T, Args extends unknown[] = unknown[]>(
  apiFunction: (...args: Args) => Promise<ApiResponse<T>>,
  options: { 
    immediate?: boolean; 
    onSuccess?: (data: T) => void; 
    onError?: (error: ApiError) => void 
  } = {}
): UseApiResponse<T, Args> {
  const [state, setState] = useState<UseApiState<T>>({
    data: null,
    error: null,
    isLoading: false,
  });

  const execute = useCallback(
    async (...args: Args) => {
      setState(prev => ({ ...prev, isLoading: true }));

      try {
        const response = await apiFunction(...args);

        if (response.error) {
          setState({ data: null, error: response.error, isLoading: false });
          options.onError?.(response.error);
        } else if (response.data) {
          setState({ data: response.data, error: null, isLoading: false });
          options.onSuccess?.(response.data);
        }
      } catch (error) {
        const apiError: ApiError = {
          code: 'UNKNOWN_ERROR',
          message: error instanceof Error ? error.message : 'An unknown error occurred',
        };
        setState({ data: null, error: apiError, isLoading: false });
        options.onError?.(apiError);
      }
    },
    [apiFunction, options]
  );

  const reset = useCallback(() => {
    setState({ data: null, error: null, isLoading: false });
  }, []);

  return {
    ...state,
    execute,
    reset,
  };
}

export function useQuery<T>(
  endpoint: string,
  options: {
    immediate?: boolean;
    config?: Parameters<typeof api.get>[1];
    onSuccess?: (data: T) => void;
    onError?: (error: ApiError) => void;
  } = {}
) {
  const apiCall = useCallback(
    () => api.get<T>(endpoint, options.config),
    [endpoint, options.config]
  );

  return useApi<T, []>(apiCall, options);
}

export function useMutation<T, D = unknown>(
  method: 'post' | 'put' | 'patch' | 'delete',
  endpoint: string,
  options: {
    config?: Parameters<typeof api.post>[2];
    onSuccess?: (data: T) => void;
    onError?: (error: ApiError) => void;
  } = {}
) {
  const apiCall = useCallback(
    (data?: D) => {
      if (method === 'delete') {
        return api.delete<T>(endpoint, options.config);
      }
      return api[method]<T, D>(endpoint, data, options.config);
    },
    [method, endpoint, options.config]
  );

  return useApi<T, [D?]>(apiCall, options);
} 

================================================
File: /src/lib/api/index.ts
================================================
export * from './types';
export * from './client';
export * from './hooks';

export const API_VERSION = 'v1'; 

================================================
File: /src/lib/api/types.ts
================================================
export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

export interface ApiResponse<T = unknown> {
  data?: T;
  error?: ApiError;
  meta?: {
    page?: number;
    limit?: number;
    total?: number;
  };
}

export interface ApiRequestConfig {
  baseURL?: string;
  headers?: Record<string, string>;
  timeout?: number;
}

export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'; 

================================================
File: /src/lib/auth/client.ts
================================================
import { api } from '../api';
import { API_ENDPOINTS } from '../api/constants';
import { AuthResponse, LoginCredentials, RegisterCredentials, User } from './types';

class AuthClient {
  private tokenKey = 'auth_token';
  private refreshTokenKey = 'refresh_token';

  constructor() {
    // Set up auth header if token exists
    const token = this.getToken();
    if (token) {
      api.setHeader('Authorization', `Bearer ${token}`);
    }
  }

  public async login(credentials: LoginCredentials): Promise<AuthResponse> {
    const response = await api.post<AuthResponse>(API_ENDPOINTS.AUTH.LOGIN, credentials);
    
    if (response.error) {
      throw response.error;
    }

    if (response.data) {
      this.setTokens(response.data.tokens);
      api.setHeader('Authorization', `Bearer ${response.data.tokens.accessToken}`);
    }

    return response.data;
  }

  public async register(credentials: RegisterCredentials): Promise<AuthResponse> {
    const response = await api.post<AuthResponse>(API_ENDPOINTS.AUTH.REGISTER, credentials);
    
    if (response.error) {
      throw response.error;
    }

    if (response.data) {
      this.setTokens(response.data.tokens);
      api.setHeader('Authorization', `Bearer ${response.data.tokens.accessToken}`);
    }

    return response.data;
  }

  public async logout(): Promise<void> {
    try {
      await api.post(API_ENDPOINTS.AUTH.LOGOUT);
    } finally {
      this.clearTokens();
      api.removeHeader('Authorization');
    }
  }

  public async getUser(): Promise<User> {
    const response = await api.get<User>(API_ENDPOINTS.AUTH.ME);
    
    if (response.error) {
      throw response.error;
    }

    return response.data;
  }

  public async refreshToken(): Promise<AuthResponse> {
    const refreshToken = this.getRefreshToken();
    if (!refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await api.post<AuthResponse>(
      API_ENDPOINTS.AUTH.REFRESH,
      { refreshToken }
    );

    if (response.error) {
      throw response.error;
    }

    if (response.data) {
      this.setTokens(response.data.tokens);
      api.setHeader('Authorization', `Bearer ${response.data.tokens.accessToken}`);
    }

    return response.data;
  }

  public isAuthenticated(): boolean {
    return !!this.getToken();
  }

  private setTokens(tokens: AuthResponse['tokens']): void {
    localStorage.setItem(this.tokenKey, tokens.accessToken);
    localStorage.setItem(this.refreshTokenKey, tokens.refreshToken);
  }

  private getToken(): string | null {
    if (typeof window === 'undefined') return null;
    return localStorage.getItem(this.tokenKey);
  }

  private getRefreshToken(): string | null {
    if (typeof window === 'undefined') return null;
    return localStorage.getItem(this.refreshTokenKey);
  }

  private clearTokens(): void {
    localStorage.removeItem(this.tokenKey);
    localStorage.removeItem(this.refreshTokenKey);
  }
}

export const authClient = new AuthClient(); 

================================================
File: /src/lib/auth/context.tsx
================================================
'use client';

import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { AuthState, LoginCredentials, RegisterCredentials } from './types';
import { authClient } from './client';

interface AuthContextType extends AuthState {
  login: (credentials: LoginCredentials) => Promise<void>;
  register: (credentials: RegisterCredentials) => Promise<void>;
  logout: () => Promise<void>;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

interface AuthProviderProps {
  children: ReactNode;
}

interface AuthError extends Error {
  message: string;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [state, setState] = useState<AuthState>({
    user: null,
    isLoading: true,
    isAuthenticated: false,
    error: null,
  });

  useEffect(() => {
    const initAuth = async () => {
      try {
        if (authClient.isAuthenticated()) {
          const user = await authClient.getUser();
          setState({
            user,
            isLoading: false,
            isAuthenticated: true,
            error: null,
          });
        } else {
          setState({
            user: null,
            isLoading: false,
            isAuthenticated: false,
            error: null,
          });
        }
      } catch {
        setState({
          user: null,
          isLoading: false,
          isAuthenticated: false,
          error: 'Failed to initialize auth',
        });
      }
    };

    initAuth();
  }, []);

  const login = async (credentials: LoginCredentials) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const response = await authClient.login(credentials);
      setState({
        user: response.user,
        isLoading: false,
        isAuthenticated: true,
        error: null,
      });
    } catch (error) {
      const authError = error as AuthError;
      setState({
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: authError.message || 'Failed to login',
      });
      throw authError;
    }
  };

  const register = async (credentials: RegisterCredentials) => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const response = await authClient.register(credentials);
      setState({
        user: response.user,
        isLoading: false,
        isAuthenticated: true,
        error: null,
      });
    } catch (error) {
      const authError = error as AuthError;
      setState({
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: authError.message || 'Failed to register',
      });
      throw authError;
    }
  };

  const logout = async () => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      await authClient.logout();
      setState({
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: null,
      });
    } catch (error) {
      const authError = error as AuthError;
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: authError.message || 'Failed to logout',
      }));
      throw authError;
    }
  };

  const refreshUser = async () => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const user = await authClient.getUser();
      setState({
        user,
        isLoading: false,
        isAuthenticated: true,
        error: null,
      });
    } catch (error) {
      const authError = error as AuthError;
      setState({
        user: null,
        isLoading: false,
        isAuthenticated: false,
        error: authError.message || 'Failed to refresh user',
      });
      throw authError;
    }
  };

  return (
    <AuthContext.Provider
      value={{
        ...state,
        login,
        register,
        logout,
        refreshUser,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
} 

================================================
File: /src/lib/auth/hooks.ts
================================================
import { useCallback } from 'react';
import { useAuth } from './context';
import { LoginCredentials, RegisterCredentials } from './types';

interface AuthResult {
  success: boolean;
  error?: string;
}

interface AuthError extends Error {
  message: string;
}

export function useLogin() {
  const { login, isLoading, error } = useAuth();

  const handleLogin = useCallback(
    async (credentials: LoginCredentials): Promise<AuthResult> => {
      try {
        await login(credentials);
        return { success: true };
      } catch (error) {
        const authError = error as AuthError;
        return {
          success: false,
          error: authError.message || 'Failed to login',
        };
      }
    },
    [login]
  );

  return {
    login: handleLogin,
    isLoading,
    error,
  };
}

export function useRegister() {
  const { register, isLoading, error } = useAuth();

  const handleRegister = useCallback(
    async (credentials: RegisterCredentials): Promise<AuthResult> => {
      try {
        await register(credentials);
        return { success: true };
      } catch (error) {
        const authError = error as AuthError;
        return {
          success: false,
          error: authError.message || 'Failed to register',
        };
      }
    },
    [register]
  );

  return {
    register: handleRegister,
    isLoading,
    error,
  };
}

export function useLogout() {
  const { logout, isLoading, error } = useAuth();

  const handleLogout = useCallback(async (): Promise<AuthResult> => {
    try {
      await logout();
      return { success: true };
    } catch (error) {
      const authError = error as AuthError;
      return {
        success: false,
        error: authError.message || 'Failed to logout',
      };
    }
  }, [logout]);

  return {
    logout: handleLogout,
    isLoading,
    error,
  };
}

export function useUser() {
  const { user, isLoading, error, refreshUser } = useAuth();

  const handleRefresh = useCallback(async (): Promise<AuthResult> => {
    try {
      await refreshUser();
      return { success: true };
    } catch (error) {
      const authError = error as AuthError;
      return {
        success: false,
        error: authError.message || 'Failed to refresh user',
      };
    }
  }, [refreshUser]);

  return {
    user,
    isLoading,
    error,
    refresh: handleRefresh,
  };
} 

================================================
File: /src/lib/auth/index.ts
================================================
export * from './types';
export * from './client';
export * from './context';
export * from './hooks';

export const AUTH_VERSION = 'v1'; 

================================================
File: /src/lib/auth/types.ts
================================================
export interface User {
  id: string;
  email: string;
  name?: string;
  avatar?: string;
  role: UserRole;
  isEmailVerified: boolean;
  createdAt: string;
  updatedAt: string;
}

export type UserRole = 'user' | 'admin' | 'moderator';

export interface AuthState {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  error: string | null;
}

export interface LoginCredentials {
  email: string;
  password: string;
}

export interface RegisterCredentials extends LoginCredentials {
  name: string;
  confirmPassword: string;
}

export interface AuthResponse {
  user: User;
  tokens: {
    accessToken: string;
    refreshToken: string;
  };
}

export interface AuthError {
  code: string;
  message: string;
}

export const AUTH_TYPES = {
  EMAIL: 'email',
  GOOGLE: 'google',
  GITHUB: 'github',
  WALLET: 'wallet',
} as const;

export type AuthType = typeof AUTH_TYPES[keyof typeof AUTH_TYPES]; 

================================================
File: /src/lib/blockchain/chains.ts
================================================
import { Chain, SUPPORTED_CHAINS } from './types';

export const chains: Record<number, Chain> = {
  [SUPPORTED_CHAINS.ETHEREUM]: {
    id: SUPPORTED_CHAINS.ETHEREUM,
    name: 'Ethereum',
    network: 'mainnet',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: [
      'https://eth-mainnet.g.alchemy.com/v2/${ALCHEMY_ID}',
      'https://mainnet.infura.io/v3/${INFURA_ID}',
    ],
    blockExplorers: [
      {
        name: 'Etherscan',
        url: 'https://etherscan.io',
      },
    ],
    testnet: false,
  },
  [SUPPORTED_CHAINS.POLYGON]: {
    id: SUPPORTED_CHAINS.POLYGON,
    name: 'Polygon',
    network: 'polygon',
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC',
      decimals: 18,
    },
    rpcUrls: [
      'https://polygon-mainnet.g.alchemy.com/v2/${ALCHEMY_ID}',
      'https://polygon-rpc.com',
    ],
    blockExplorers: [
      {
        name: 'PolygonScan',
        url: 'https://polygonscan.com',
      },
    ],
    testnet: false,
  },
  [SUPPORTED_CHAINS.ARBITRUM]: {
    id: SUPPORTED_CHAINS.ARBITRUM,
    name: 'Arbitrum',
    network: 'arbitrum',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: [
      'https://arb-mainnet.g.alchemy.com/v2/${ALCHEMY_ID}',
      'https://arbitrum.public-rpc.com',
    ],
    blockExplorers: [
      {
        name: 'Arbiscan',
        url: 'https://arbiscan.io',
      },
    ],
    testnet: false,
  },
  [SUPPORTED_CHAINS.OPTIMISM]: {
    id: SUPPORTED_CHAINS.OPTIMISM,
    name: 'Optimism',
    network: 'optimism',
    nativeCurrency: {
      name: 'Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: [
      'https://opt-mainnet.g.alchemy.com/v2/${ALCHEMY_ID}',
      'https://mainnet.optimism.io',
    ],
    blockExplorers: [
      {
        name: 'OptimismScan',
        url: 'https://optimistic.etherscan.io',
      },
    ],
    testnet: false,
  },
  [SUPPORTED_CHAINS.GOERLI]: {
    id: SUPPORTED_CHAINS.GOERLI,
    name: 'Goerli',
    network: 'goerli',
    nativeCurrency: {
      name: 'Goerli Ether',
      symbol: 'ETH',
      decimals: 18,
    },
    rpcUrls: [
      'https://eth-goerli.g.alchemy.com/v2/${ALCHEMY_ID}',
      'https://goerli.infura.io/v3/${INFURA_ID}',
    ],
    blockExplorers: [
      {
        name: 'Etherscan',
        url: 'https://goerli.etherscan.io',
      },
    ],
    testnet: true,
  },
  [SUPPORTED_CHAINS.MUMBAI]: {
    id: SUPPORTED_CHAINS.MUMBAI,
    name: 'Mumbai',
    network: 'maticmum',
    nativeCurrency: {
      name: 'MATIC',
      symbol: 'MATIC',
      decimals: 18,
    },
    rpcUrls: [
      'https://polygon-mumbai.g.alchemy.com/v2/${ALCHEMY_ID}',
      'https://rpc-mumbai.maticvigil.com',
    ],
    blockExplorers: [
      {
        name: 'PolygonScan',
        url: 'https://mumbai.polygonscan.com',
      },
    ],
    testnet: true,
  },
};

export function getChainById(chainId: number): Chain | undefined {
  return chains[chainId];
}

export function isTestnet(chainId: number): boolean {
  return chains[chainId]?.testnet ?? false;
}

export function getBlockExplorer(chainId: number): string {
  return chains[chainId]?.blockExplorers[0]?.url ?? '';
}

export function formatBlockExplorerLink(chainId: number, hash: string, type: 'tx' | 'address' = 'tx'): string {
  const baseUrl = getBlockExplorer(chainId);
  if (!baseUrl) return '';
  return `${baseUrl}/${type}/${hash}`;
} 

================================================
File: /src/lib/blockchain/client.ts
================================================
import { Chain, TransactionRequest, WalletError, WalletProvider, WalletState } from './types';
import { getChainById } from './chains';

interface EthereumProvider {
  request(args: { method: string; params?: unknown[] }): Promise<unknown>;
}

declare global {
  interface Window {
    ethereum?: EthereumProvider;
  }
}

class BlockchainClient {
  private provider: EthereumProvider | null = null;
  private walletProvider: WalletProvider | null = null;

  constructor() {
    if (typeof window !== 'undefined') {
      this.provider = window.ethereum ?? null;
    }
  }

  public async connect(provider: WalletProvider = 'metamask'): Promise<WalletState> {
    try {
      if (!this.provider) {
        throw this.createError('NO_PROVIDER', 'No wallet provider found');
      }

      this.walletProvider = provider;

      // Request account access
      const accounts = (await this.provider.request({ method: 'eth_requestAccounts' })) as string[];
      const chainId = (await this.provider.request({ method: 'eth_chainId' })) as string;

      return {
        address: accounts[0],
        chainId: parseInt(chainId, 16),
        isConnecting: false,
        isConnected: true,
        isDisconnected: false,
        error: null,
      };
    } catch (error) {
      const err = error as Error;
      throw this.createError('CONNECT_ERROR', err.message);
    }
  }

  public async disconnect(): Promise<void> {
    this.walletProvider = null;
  }

  public async switchChain(chainId: number): Promise<void> {
    try {
      if (!this.provider) {
        throw this.createError('NO_PROVIDER', 'No wallet provider found');
      }

      const chain = getChainById(chainId);
      if (!chain) {
        throw this.createError('INVALID_CHAIN', 'Invalid chain ID');
      }

      await this.provider.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: `0x${chainId.toString(16)}` }],
      });
    } catch (error) {
      const err = error as { code: number; message: string };
      // If the chain hasn't been added to the wallet
      if (err.code === 4902) {
        await this.addChain(chainId);
      } else {
        throw this.createError('SWITCH_CHAIN_ERROR', err.message);
      }
    }
  }

  public async addChain(chainId: number): Promise<void> {
    try {
      if (!this.provider) {
        throw this.createError('NO_PROVIDER', 'No wallet provider found');
      }

      const chain = getChainById(chainId);
      if (!chain) {
        throw this.createError('INVALID_CHAIN', 'Invalid chain ID');
      }

      await this.provider.request({
        method: 'wallet_addEthereumChain',
        params: [this.formatChainForWallet(chain)],
      });
    } catch (error) {
      const err = error as Error;
      throw this.createError('ADD_CHAIN_ERROR', err.message);
    }
  }

  public async sendTransaction(request: TransactionRequest): Promise<string> {
    try {
      if (!this.provider) {
        throw this.createError('NO_PROVIDER', 'No wallet provider found');
      }

      const accounts = (await this.provider.request({ method: 'eth_accounts' })) as string[];
      const txHash = (await this.provider.request({
        method: 'eth_sendTransaction',
        params: [{
          from: accounts[0],
          to: request.to,
          value: request.value ? `0x${BigInt(request.value).toString(16)}` : undefined,
          data: request.data,
          chainId: request.chainId ? `0x${request.chainId.toString(16)}` : undefined,
        }],
      })) as string;

      return txHash;
    } catch (error) {
      const err = error as Error;
      throw this.createError('TRANSACTION_ERROR', err.message);
    }
  }

  public async signMessage(message: string): Promise<string> {
    try {
      if (!this.provider) {
        throw this.createError('NO_PROVIDER', 'No wallet provider found');
      }

      const accounts = (await this.provider.request({ method: 'eth_accounts' })) as string[];
      const signature = (await this.provider.request({
        method: 'personal_sign',
        params: [message, accounts[0]],
      })) as string;

      return signature;
    } catch (error) {
      const err = error as Error;
      throw this.createError('SIGN_ERROR', err.message);
    }
  }

  public isConnected(): boolean {
    return !!this.walletProvider;
  }

  private createError(code: string, message: string): WalletError {
    return {
      code,
      message,
    };
  }

  private formatChainForWallet(chain: Chain) {
    return {
      chainId: `0x${chain.id.toString(16)}`,
      chainName: chain.name,
      nativeCurrency: chain.nativeCurrency,
      rpcUrls: chain.rpcUrls,
      blockExplorerUrls: chain.blockExplorers.map(explorer => explorer.url),
    };
  }
}

export const blockchainClient = new BlockchainClient(); 

================================================
File: /src/lib/blockchain/context.tsx
================================================
'use client';

import { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { WalletState, WalletProvider, TransactionRequest, WalletError } from './types';
import { blockchainClient } from './client';

interface BlockchainContextType extends WalletState {
  connect: (provider?: WalletProvider) => Promise<void>;
  disconnect: () => Promise<void>;
  switchChain: (chainId: number) => Promise<void>;
  sendTransaction: (request: TransactionRequest) => Promise<string>;
  signMessage: (message: string) => Promise<string>;
}

const BlockchainContext = createContext<BlockchainContextType | undefined>(undefined);

interface BlockchainProviderProps {
  children: ReactNode;
}

export function BlockchainProvider({ children }: BlockchainProviderProps) {
  const [state, setState] = useState<WalletState>({
    address: null,
    chainId: null,
    isConnecting: false,
    isConnected: false,
    isDisconnected: true,
    error: null,
  });

  useEffect(() => {
    const initWallet = async () => {
      if (blockchainClient.isConnected()) {
        try {
          const walletState = await blockchainClient.connect();
          setState(walletState);
        } catch (error) {
          const err = error as WalletError;
          setState(prev => ({
            ...prev,
            error: err.message,
          }));
        }
      }
    };

    initWallet();
  }, []);

  const connect = async (provider?: WalletProvider) => {
    setState(prev => ({ ...prev, isConnecting: true, error: null }));
    try {
      const walletState = await blockchainClient.connect(provider);
      setState(walletState);
    } catch (error) {
      const err = error as WalletError;
      setState({
        address: null,
        chainId: null,
        isConnecting: false,
        isConnected: false,
        isDisconnected: true,
        error: err.message,
      });
      throw err;
    }
  };

  const disconnect = async () => {
    try {
      await blockchainClient.disconnect();
      setState({
        address: null,
        chainId: null,
        isConnecting: false,
        isConnected: false,
        isDisconnected: true,
        error: null,
      });
    } catch (error) {
      const err = error as WalletError;
      setState(prev => ({
        ...prev,
        error: err.message,
      }));
      throw err;
    }
  };

  const switchChain = async (chainId: number) => {
    try {
      await blockchainClient.switchChain(chainId);
      setState(prev => ({
        ...prev,
        chainId,
        error: null,
      }));
    } catch (error) {
      const err = error as WalletError;
      setState(prev => ({
        ...prev,
        error: err.message,
      }));
      throw err;
    }
  };

  const sendTransaction = async (request: TransactionRequest) => {
    try {
      return await blockchainClient.sendTransaction(request);
    } catch (error) {
      const err = error as WalletError;
      setState(prev => ({
        ...prev,
        error: err.message,
      }));
      throw err;
    }
  };

  const signMessage = async (message: string) => {
    try {
      return await blockchainClient.signMessage(message);
    } catch (error) {
      const err = error as WalletError;
      setState(prev => ({
        ...prev,
        error: err.message,
      }));
      throw err;
    }
  };

  return (
    <BlockchainContext.Provider
      value={{
        ...state,
        connect,
        disconnect,
        switchChain,
        sendTransaction,
        signMessage,
      }}
    >
      {children}
    </BlockchainContext.Provider>
  );
}

export function useBlockchain() {
  const context = useContext(BlockchainContext);
  if (context === undefined) {
    throw new Error('useBlockchain must be used within a BlockchainProvider');
  }
  return context;
} 

================================================
File: /src/lib/blockchain/hooks.ts
================================================
import { useCallback } from 'react';
import { useBlockchain } from './context';
import { TransactionRequest, WalletProvider, WalletError } from './types';
import { formatBlockExplorerLink } from './chains';

interface BlockchainResult {
  success: boolean;
  error?: string;
}

interface TransactionResult extends BlockchainResult {
  hash?: string;
  explorerLink?: string;
}

interface SignMessageResult extends BlockchainResult {
  signature?: string;
}

export function useWallet() {
  const {
    address,
    chainId,
    isConnecting,
    isConnected,
    isDisconnected,
    error,
    connect,
    disconnect,
  } = useBlockchain();

  const handleConnect = useCallback(
    async (provider?: WalletProvider): Promise<BlockchainResult> => {
      try {
        await connect(provider);
        return { success: true };
      } catch (error) {
        const err = error as WalletError;
        return {
          success: false,
          error: err.message || 'Failed to connect wallet',
        };
      }
    },
    [connect]
  );

  const handleDisconnect = useCallback(async (): Promise<BlockchainResult> => {
    try {
      await disconnect();
      return { success: true };
    } catch (error) {
      const err = error as WalletError;
      return {
        success: false,
        error: err.message || 'Failed to disconnect wallet',
      };
    }
  }, [disconnect]);

  return {
    address,
    chainId,
    isConnecting,
    isConnected,
    isDisconnected,
    error,
    connect: handleConnect,
    disconnect: handleDisconnect,
  };
}

export function useNetwork() {
  const { chainId, error, switchChain } = useBlockchain();

  const handleSwitchChain = useCallback(
    async (newChainId: number): Promise<BlockchainResult> => {
      try {
        await switchChain(newChainId);
        return { success: true };
      } catch (error) {
        const err = error as WalletError;
        return {
          success: false,
          error: err.message || 'Failed to switch chain',
        };
      }
    },
    [switchChain]
  );

  return {
    chainId,
    error,
    switchChain: handleSwitchChain,
  };
}

export function useTransaction() {
  const { chainId, error, sendTransaction } = useBlockchain();

  const handleSendTransaction = useCallback(
    async (request: TransactionRequest): Promise<TransactionResult> => {
      try {
        const txHash = await sendTransaction(request);
        const explorerLink = chainId ? formatBlockExplorerLink(chainId, txHash) : undefined;
        return {
          success: true,
          hash: txHash,
          explorerLink,
        };
      } catch (error) {
        const err = error as WalletError;
        return {
          success: false,
          error: err.message || 'Failed to send transaction',
        };
      }
    },
    [chainId, sendTransaction]
  );

  return {
    error,
    sendTransaction: handleSendTransaction,
  };
}

export function useSignMessage() {
  const { error, signMessage } = useBlockchain();

  const handleSignMessage = useCallback(
    async (message: string): Promise<SignMessageResult> => {
      try {
        const signature = await signMessage(message);
        return {
          success: true,
          signature,
        };
      } catch (error) {
        const err = error as WalletError;
        return {
          success: false,
          error: err.message || 'Failed to sign message',
        };
      }
    },
    [signMessage]
  );

  return {
    error,
    signMessage: handleSignMessage,
  };
} 

================================================
File: /src/lib/blockchain/index.ts
================================================
export * from './types';
export * from './chains';
export * from './client';
export * from './context';
export * from './hooks';

export const BLOCKCHAIN_VERSION = 'v1'; 

================================================
File: /src/lib/blockchain/types.ts
================================================
export interface Chain {
  id: number;
  name: string;
  network: string;
  nativeCurrency: {
    name: string;
    symbol: string;
    decimals: number;
  };
  rpcUrls: string[];
  blockExplorers: {
    name: string;
    url: string;
  }[];
  testnet: boolean;
}

export interface WalletState {
  address: string | null;
  chainId: number | null;
  isConnecting: boolean;
  isConnected: boolean;
  isDisconnected: boolean;
  error: string | null;
}

export interface Transaction {
  hash: string;
  from: string;
  to: string;
  value: string;
  data?: string;
  chainId: number;
  status?: 'pending' | 'success' | 'failed';
  timestamp: number;
}

export interface TransactionRequest {
  to: string;
  value?: string;
  data?: string;
  chainId?: number;
}

export interface SignMessageRequest {
  message: string;
  address: string;
}

export const SUPPORTED_CHAINS = {
  ETHEREUM: 1,
  POLYGON: 137,
  ARBITRUM: 42161,
  OPTIMISM: 10,
  // Testnets
  GOERLI: 5,
  MUMBAI: 80001,
} as const;

export type ChainId = typeof SUPPORTED_CHAINS[keyof typeof SUPPORTED_CHAINS];

export interface WalletError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

export type WalletProvider = 'metamask' | 'walletconnect' | 'coinbase'; 

================================================
File: /src/lib/routing/types.ts
================================================
import { Route } from 'next';

export type InternalRoute = Route;
export type ExternalRoute = string;
export type RouteType = InternalRoute | ExternalRoute;

export interface NavigationLink {
  label: string;
  href: RouteType;
  isExternal?: boolean;
}

export interface NavigationGroup {
  title: string;
  links: NavigationLink[];
}

export interface SocialLink extends NavigationLink {
  icon: React.ReactNode;
}

export function isExternalRoute(route: RouteType): route is ExternalRoute {
  return typeof route === 'string' && (route.startsWith('http://') || route.startsWith('https://'));
}

export function createInternalRoute(path: string): InternalRoute {
  return path as Route;
}

export function createExternalRoute(url: string): ExternalRoute {
  // Validate URL format using string checks
  if (!url.startsWith('http://') && !url.startsWith('https://')) {
    throw new Error(`Invalid URL format: ${url}. URL must start with http:// or https://`);
  }
  return url;
} 

================================================
File: /src/lib/storage/client.ts
================================================
import { StorageConfig, StorageType, StorageProvider, UploadOptions, UploadResult, StorageError } from './types';
import { localStorageProvider } from './providers/local';
import { ipfsStorageProvider } from './providers/ipfs';

class StorageClient {
  private config: StorageConfig;
  private providers: Map<StorageType, StorageProvider>;

  constructor(config: StorageConfig = {}) {
    this.config = config;
    this.providers = new Map();

    // Initialize providers
    this.providers.set('local', localStorageProvider);
    this.providers.set('ipfs', ipfsStorageProvider);
  }

  public getProvider(type: StorageType): StorageProvider {
    const provider = this.providers.get(type);
    if (!provider) {
      throw this.createError('INVALID_PROVIDER', `Provider ${type} not found`);
    }
    return provider;
  }

  public async store<T>(
    key: string,
    data: T,
    type: StorageType = 'local'
  ): Promise<void> {
    try {
      const provider = this.getProvider(type);

      if (type === 'local' && provider.set) {
        await provider.set(key, data);
      } else if (provider.upload) {
        await provider.upload(data as unknown as string | Blob | File);
      } else {
        throw this.createError('OPERATION_NOT_SUPPORTED', 'Store operation not supported for this provider');
      }
    } catch (error) {
      const err = error as Error;
      throw this.createError('STORE_ERROR', err.message);
    }
  }

  public async retrieve<T>(
    key: string,
    type: StorageType = 'local'
  ): Promise<T | null> {
    try {
      const provider = this.getProvider(type);

      if (type === 'local' && provider.get) {
        return await provider.get<T>(key);
      } else if (provider.download) {
        const data = await provider.download(key);
        return data as unknown as T;
      }
      throw this.createError('OPERATION_NOT_SUPPORTED', 'Retrieve operation not supported for this provider');
    } catch (error) {
      const err = error as Error;
      throw this.createError('RETRIEVE_ERROR', err.message);
    }
  }

  public async upload(
    data: string | Blob | File,
    options: UploadOptions = {},
    type: StorageType = 'ipfs'
  ): Promise<UploadResult> {
    try {
      const provider = this.getProvider(type);
      if (!provider.upload) {
        throw this.createError('OPERATION_NOT_SUPPORTED', 'Upload operation not supported for this provider');
      }
      return await provider.upload(data, {
        ...options,
        encryption: options.encryption ?? this.config.encryption,
      });
    } catch (error) {
      const err = error as Error;
      throw this.createError('UPLOAD_ERROR', err.message);
    }
  }

  public async download(
    hash: string,
    type: StorageType = 'ipfs'
  ): Promise<Blob> {
    try {
      const provider = this.getProvider(type);
      if (!provider.download) {
        throw this.createError('OPERATION_NOT_SUPPORTED', 'Download operation not supported for this provider');
      }
      return await provider.download(hash);
    } catch (error) {
      const err = error as Error;
      throw this.createError('DOWNLOAD_ERROR', err.message);
    }
  }

  public async remove(
    key: string,
    type: StorageType = 'local'
  ): Promise<void> {
    try {
      const provider = this.getProvider(type);
      if (type === 'local' && provider.remove) {
        await provider.remove(key);
      } else {
        throw this.createError('OPERATION_NOT_SUPPORTED', 'Remove operation not supported for this provider');
      }
    } catch (error) {
      const err = error as Error;
      throw this.createError('REMOVE_ERROR', err.message);
    }
  }

  public async clear(type: StorageType = 'local'): Promise<void> {
    try {
      const provider = this.getProvider(type);
      if (type === 'local' && provider.clear) {
        await provider.clear();
      } else {
        throw this.createError('OPERATION_NOT_SUPPORTED', 'Clear operation not supported for this provider');
      }
    } catch (error) {
      const err = error as Error;
      throw this.createError('CLEAR_ERROR', err.message);
    }
  }

  private createError(code: string, message: string): StorageError {
    return {
      code,
      message,
    };
  }
}

export const storageClient = new StorageClient(); 

================================================
File: /src/lib/storage/encryption.ts
================================================
import { EncryptionResult, DecryptionInput, StorageError } from './types';

interface CryptoError extends Error {
  code?: string;
  name: string;
}

export class EncryptionService {
  private static readonly ALGORITHM = 'AES-GCM';
  private static readonly KEY_LENGTH = 256;
  private static readonly IV_LENGTH = 12;
  private key: CryptoKey | null = null;

  public async initialize(key?: string): Promise<void> {
    if (!this.isSupported()) {
      throw this.createError('ENCRYPTION_NOT_SUPPORTED', 'Web Crypto API is not supported in this environment');
    }

    try {
      if (key) {
        // Convert string key to CryptoKey
        const keyBuffer = new TextEncoder().encode(key);
        this.key = await crypto.subtle.importKey(
          'raw',
          keyBuffer,
          { name: EncryptionService.ALGORITHM, length: EncryptionService.KEY_LENGTH },
          false,
          ['encrypt', 'decrypt']
        );
      } else {
        // Generate a new random key
        this.key = await crypto.subtle.generateKey(
          { name: EncryptionService.ALGORITHM, length: EncryptionService.KEY_LENGTH },
          true,
          ['encrypt', 'decrypt']
        );
      }
    } catch (error) {
      const err = error as CryptoError;
      throw this.createError('ENCRYPTION_INIT_ERROR', err.message || 'Failed to initialize encryption');
    }
  }

  public async encrypt(data: string): Promise<EncryptionResult> {
    if (!this.key) {
      throw this.createError('ENCRYPTION_NOT_INITIALIZED', 'Encryption service not initialized');
    }

    try {
      // Generate random IV
      const iv = crypto.getRandomValues(new Uint8Array(EncryptionService.IV_LENGTH));
      
      // Encrypt the data
      const encodedData = new TextEncoder().encode(data);
      const encryptedBuffer = await crypto.subtle.encrypt(
        { name: EncryptionService.ALGORITHM, iv },
        this.key,
        encodedData
      );

      // Convert to base64 strings
      const encryptedBase64 = this.arrayBufferToBase64(encryptedBuffer);
      const ivBase64 = this.arrayBufferToBase64(iv);

      return {
        data: encryptedBase64,
        iv: ivBase64,
      };
    } catch (error) {
      const err = error as CryptoError;
      throw this.createError('ENCRYPTION_ERROR', err.message || 'Failed to encrypt data');
    }
  }

  public async decrypt({ data, iv }: DecryptionInput): Promise<string> {
    if (!this.key) {
      throw this.createError('ENCRYPTION_NOT_INITIALIZED', 'Encryption service not initialized');
    }

    try {
      // Convert base64 strings back to buffers
      const encryptedBuffer = this.base64ToArrayBuffer(data);
      const ivBuffer = this.base64ToArrayBuffer(iv);

      // Decrypt the data
      const decryptedBuffer = await crypto.subtle.decrypt(
        { name: EncryptionService.ALGORITHM, iv: ivBuffer },
        this.key,
        encryptedBuffer
      );

      // Convert back to string
      return new TextDecoder().decode(decryptedBuffer);
    } catch (error) {
      const err = error as CryptoError;
      throw this.createError('DECRYPTION_ERROR', err.message || 'Failed to decrypt data');
    }
  }

  private isSupported(): boolean {
    return typeof crypto !== 'undefined' && 
           typeof crypto.subtle !== 'undefined' && 
           typeof TextEncoder !== 'undefined';
  }

  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  private base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
      bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
  }

  private createError(code: string, message: string): StorageError {
    return {
      code,
      message,
    };
  }
}

export const encryptionService = new EncryptionService(); 

================================================
File: /src/lib/storage/hooks.ts
================================================
import { useState, useCallback } from 'react';
import { StorageType, UploadOptions, UploadResult, StorageError } from './types';
import { storageClient } from './client';

interface UseStorageState<T> {
  data: T | null;
  isLoading: boolean;
  error: string | null;
}

interface StorageResult {
  success: boolean;
  error?: string;
}

interface StorageRetrieveResult<T> extends StorageResult {
  data?: T | null;
}

interface UploadStorageResult extends StorageResult {
  result?: UploadResult;
}

interface DownloadStorageResult extends StorageResult {
  data?: Blob;
}

export function useStorage<T>(
  key: string,
  type: StorageType = 'local'
) {
  const [state, setState] = useState<UseStorageState<T>>({
    data: null,
    isLoading: false,
    error: null,
  });

  const store = useCallback(
    async (data: T): Promise<StorageResult> => {
      setState(prev => ({ ...prev, isLoading: true, error: null }));
      try {
        await storageClient.store(key, data, type);
        setState({
          data,
          isLoading: false,
          error: null,
        });
        return { success: true };
      } catch (error) {
        const err = error as StorageError;
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: err.message,
        }));
        return {
          success: false,
          error: err.message,
        };
      }
    },
    [key, type]
  );

  const retrieve = useCallback(async (): Promise<StorageRetrieveResult<T>> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      const data = await storageClient.retrieve<T>(key, type);
      setState({
        data,
        isLoading: false,
        error: null,
      });
      return { success: true, data };
    } catch (error) {
      const err = error as StorageError;
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: err.message,
      }));
      return {
        success: false,
        error: err.message,
      };
    }
  }, [key, type]);

  const remove = useCallback(async (): Promise<StorageResult> => {
    setState(prev => ({ ...prev, isLoading: true, error: null }));
    try {
      await storageClient.remove(key, type);
      setState({
        data: null,
        isLoading: false,
        error: null,
      });
      return { success: true };
    } catch (error) {
      const err = error as StorageError;
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: err.message,
      }));
      return {
        success: false,
        error: err.message,
      };
    }
  }, [key, type]);

  return {
    ...state,
    store,
    retrieve,
    remove,
  };
}

export function useUpload(type: StorageType = 'ipfs') {
  const [state, setState] = useState<{
    isLoading: boolean;
    error: string | null;
    result: UploadResult | null;
  }>({
    isLoading: false,
    error: null,
    result: null,
  });

  const upload = useCallback(
    async (data: string | Blob | File, options: UploadOptions = {}): Promise<UploadStorageResult> => {
      setState(prev => ({ ...prev, isLoading: true, error: null }));
      try {
        const result = await storageClient.upload(data, options, type);
        setState({
          isLoading: false,
          error: null,
          result,
        });
        return { success: true, result };
      } catch (error) {
        const err = error as StorageError;
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: err.message,
        }));
        return {
          success: false,
          error: err.message,
        };
      }
    },
    [type]
  );

  const download = useCallback(
    async (hash: string): Promise<DownloadStorageResult> => {
      setState(prev => ({ ...prev, isLoading: true, error: null }));
      try {
        const data = await storageClient.download(hash, type);
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: null,
        }));
        return { success: true, data };
      } catch (error) {
        const err = error as StorageError;
        setState(prev => ({
          ...prev,
          isLoading: false,
          error: err.message,
        }));
        return {
          success: false,
          error: err.message,
        };
      }
    },
    [type]
  );

  return {
    ...state,
    upload,
    download,
  };
} 

================================================
File: /src/lib/storage/index.ts
================================================
export * from './types';
export * from './client';
export * from './hooks';
export * from './encryption';
export * from './providers/local';
export * from './providers/ipfs';

export const STORAGE_VERSION = 'v1'; 

================================================
File: /src/lib/storage/types.ts
================================================
export interface StorageConfig {
  prefix?: string;
  encryption?: boolean;
  encryptionKey?: string;
  ipfsGateway?: string;
  arweaveGateway?: string;
}

export interface StorageItem<T = unknown> {
  key: string;
  value: T;
  timestamp: number;
  encrypted?: boolean;
}

export interface StorageMetadata {
  contentType: string;
  size: number;
  created: number;
  modified: number;
  hash?: string;
  encryption?: {
    algorithm: string;
    iv: string;
  };
}

export interface UploadOptions {
  contentType?: string;
  encryption?: boolean;
  permanent?: boolean;
  metadata?: Record<string, unknown>;
}

export interface UploadResult {
  url: string;
  hash: string;
  size: number;
  metadata: StorageMetadata;
}

export interface StorageProvider {
  // Common properties
  type: StorageType;
  name: string;
  description: string;
  permanent: boolean;
  encryption: boolean;

  // Local storage methods
  set?<T>(key: string, value: T): Promise<void>;
  get?<T>(key: string): Promise<T | null>;
  remove?(key: string): Promise<void>;
  clear?(): Promise<void>;

  // IPFS/Arweave methods
  upload?(data: string | Blob | File, options?: UploadOptions): Promise<UploadResult>;
  download?(hash: string): Promise<Blob>;
  getMetadata?(hash: string): Promise<StorageMetadata>;
}

export const STORAGE_TYPES = {
  LOCAL: 'local',
  IPFS: 'ipfs',
  ARWEAVE: 'arweave',
} as const;

export type StorageType = typeof STORAGE_TYPES[keyof typeof STORAGE_TYPES];

export interface StorageError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
}

export interface EncryptionResult {
  data: string;
  iv: string;
}

export interface DecryptionInput {
  data: string;
  iv: string;
  algorithm?: string;
} 

================================================
File: /src/lib/storage/providers/ipfs.ts
================================================
import { StorageConfig, StorageError, StorageMetadata, UploadOptions, UploadResult, StorageProvider, StorageType } from '../types';
import { encryptionService } from '../encryption';

interface IPFSError extends Error {
  code?: string;
  name: string;
}

interface IPFSUploadResponse {
  Hash: string;
  Name: string;
  Size: string;
}

interface EncryptedContent {
  data: string;
  iv: string;
}

export class IPFSStorageProvider implements StorageProvider {
  public readonly type: StorageType = 'ipfs';
  public readonly name = 'IPFS Storage';
  public readonly description = 'Decentralized IPFS storage provider';
  public readonly permanent = true;
  public readonly encryption: boolean;

  private config: StorageConfig;
  private gateway: string;

  constructor(config: StorageConfig = {}) {
    this.config = {
      encryption: false,
      ipfsGateway: 'https://ipfs.io/ipfs/',
      ...config,
    };
    this.gateway = this.config.ipfsGateway!;
    this.encryption = this.config.encryption || false;

    if (this.config.encryption && this.config.encryptionKey) {
      encryptionService.initialize(this.config.encryptionKey);
    }
  }

  public async upload(
    data: string | Blob | File,
    options: UploadOptions = {}
  ): Promise<UploadResult> {
    try {
      let content: Blob;
      let contentType = options.contentType || 'application/octet-stream';
      let encryptedContent: EncryptedContent | undefined;

      if (typeof data === 'string') {
        // If encryption is enabled, encrypt the string data
        if (this.config.encryption) {
          encryptedContent = await encryptionService.encrypt(data);
          content = new Blob([JSON.stringify(encryptedContent)], { type: 'application/json' });
          contentType = 'application/json+encrypted';
        } else {
          content = new Blob([data], { type: contentType });
        }
      } else {
        content = data;
      }

      // Create form data
      const formData = new FormData();
      formData.append('file', content);

      // Upload to IPFS using Infura or other IPFS service
      const response = await fetch('https://ipfs.infura.io:5001/api/v0/add', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to upload to IPFS');
      }

      const result = (await response.json()) as IPFSUploadResponse;
      const hash = result.Hash;

      const metadata: StorageMetadata = {
        contentType,
        size: content.size,
        created: Date.now(),
        modified: Date.now(),
        hash,
        encryption: this.config.encryption && encryptedContent ? {
          algorithm: 'AES-GCM',
          iv: encryptedContent.iv,
        } : undefined,
      };

      return {
        url: `${this.gateway}${hash}`,
        hash,
        size: content.size,
        metadata,
      };
    } catch (error) {
      const err = error as IPFSError;
      throw this.createError('UPLOAD_ERROR', err.message || 'Failed to upload to IPFS');
    }
  }

  public async download(hash: string): Promise<Blob> {
    try {
      const response = await fetch(`${this.gateway}${hash}`);
      
      if (!response.ok) {
        throw new Error('Failed to download from IPFS');
      }

      const data = await response.blob();

      // If the content is encrypted, decrypt it
      if (this.config.encryption) {
        const text = await data.text();
        const encrypted = JSON.parse(text) as EncryptedContent;
        const decrypted = await encryptionService.decrypt(encrypted);
        return new Blob([decrypted], { type: 'text/plain' });
      }

      return data;
    } catch (error) {
      const err = error as IPFSError;
      throw this.createError('DOWNLOAD_ERROR', err.message || 'Failed to download from IPFS');
    }
  }

  public async getMetadata(hash: string): Promise<StorageMetadata> {
    try {
      const response = await fetch(`${this.gateway}${hash}`, {
        method: 'HEAD',
      });

      if (!response.ok) {
        throw new Error('Failed to get metadata from IPFS');
      }

      return {
        contentType: response.headers.get('content-type') || 'application/octet-stream',
        size: parseInt(response.headers.get('content-length') || '0'),
        created: Date.now(), // IPFS doesn't provide creation time
        modified: Date.now(),
        hash,
        encryption: this.config.encryption ? {
          algorithm: 'AES-GCM',
          iv: '', // Set if encrypted
        } : undefined,
      };
    } catch (error) {
      const err = error as IPFSError;
      throw this.createError('METADATA_ERROR', err.message || 'Failed to get metadata from IPFS');
    }
  }

  private createError(code: string, message: string): StorageError {
    return {
      code,
      message,
    };
  }
}

export const ipfsStorageProvider = new IPFSStorageProvider(); 

================================================
File: /src/lib/storage/providers/local.ts
================================================
import { StorageConfig, StorageItem, StorageError, StorageMetadata, StorageProvider, StorageType } from '../types';
import { encryptionService } from '../encryption';

interface EncryptedValue {
  data: string;
  iv: string;
}

interface LocalStorageError extends Error {
  code?: string;
  name: string;
}

export class LocalStorageProvider implements StorageProvider {
  public readonly type: StorageType = 'local';
  public readonly name = 'Local Storage';
  public readonly description = 'Browser-based local storage provider';
  public readonly permanent = false;
  public readonly encryption: boolean;

  private config: StorageConfig;

  constructor(config: StorageConfig = {}) {
    this.config = {
      prefix: 'ai_tribes_',
      encryption: false,
      ...config,
    };
    this.encryption = this.config.encryption || false;

    if (this.config.encryption && this.config.encryptionKey) {
      encryptionService.initialize(this.config.encryptionKey);
    }
  }

  public async set<T>(key: string, value: T): Promise<void> {
    try {
      const item: StorageItem<T> = {
        key,
        value,
        timestamp: Date.now(),
        encrypted: false,
      };

      if (this.config.encryption) {
        const stringValue = JSON.stringify(value);
        const encrypted = await encryptionService.encrypt(stringValue);
        item.value = encrypted as unknown as T;
        item.encrypted = true;
      }

      const fullKey = this.getFullKey(key);
      localStorage.setItem(fullKey, JSON.stringify(item));
    } catch (error) {
      const err = error as LocalStorageError;
      throw this.createError('SET_ERROR', err.message || 'Failed to set item');
    }
  }

  public async get<T>(key: string): Promise<T | null> {
    try {
      const fullKey = this.getFullKey(key);
      const rawItem = localStorage.getItem(fullKey);

      if (!rawItem) {
        return null;
      }

      const item: StorageItem<T | EncryptedValue> = JSON.parse(rawItem);

      if (item.encrypted && this.config.encryption) {
        const encryptedValue = item.value as EncryptedValue;
        const decrypted = await encryptionService.decrypt({
          data: encryptedValue.data,
          iv: encryptedValue.iv,
        });
        return JSON.parse(decrypted) as T;
      }

      return item.value as T;
    } catch (error) {
      const err = error as LocalStorageError;
      throw this.createError('GET_ERROR', err.message || 'Failed to get item');
    }
  }

  public async remove(key: string): Promise<void> {
    try {
      const fullKey = this.getFullKey(key);
      localStorage.removeItem(fullKey);
    } catch (error) {
      const err = error as LocalStorageError;
      throw this.createError('REMOVE_ERROR', err.message || 'Failed to remove item');
    }
  }

  public async clear(): Promise<void> {
    try {
      const keys = this.getAllKeys();
      keys.forEach(key => localStorage.removeItem(key));
    } catch (error) {
      const err = error as LocalStorageError;
      throw this.createError('CLEAR_ERROR', err.message || 'Failed to clear storage');
    }
  }

  public async getMetadata(key: string): Promise<StorageMetadata> {
    try {
      const fullKey = this.getFullKey(key);
      const rawItem = localStorage.getItem(fullKey);

      if (!rawItem) {
        throw this.createError('NOT_FOUND', `Item with key ${key} not found`);
      }

      const item: StorageItem<unknown> = JSON.parse(rawItem);
      const size = new Blob([JSON.stringify(item.value)]).size;

      return {
        contentType: 'application/json',
        size,
        created: item.timestamp,
        modified: item.timestamp,
        encryption: item.encrypted ? {
          algorithm: 'AES-GCM',
          iv: (item.value as EncryptedValue).iv,
        } : undefined,
      };
    } catch (error) {
      const err = error as LocalStorageError;
      throw this.createError('METADATA_ERROR', err.message || 'Failed to get metadata');
    }
  }

  public async keys(): Promise<string[]> {
    return this.getAllKeys().map(key => this.removePrefix(key));
  }

  private getFullKey(key: string): string {
    return `${this.config.prefix}${key}`;
  }

  private removePrefix(key: string): string {
    return key.replace(this.config.prefix!, '');
  }

  private getAllKeys(): string[] {
    const keys: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(this.config.prefix!)) {
        keys.push(key);
      }
    }
    return keys;
  }

  private createError(code: string, message: string): StorageError {
    return {
      code,
      message,
    };
  }
}

export const localStorageProvider = new LocalStorageProvider(); 

